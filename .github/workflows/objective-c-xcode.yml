name: Generate and Fuzz Audio Files

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-generate:
    runs-on: macos-latest
    timeout-minutes: 30

    steps:
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          echo "Listing directory contents at $(date)"
          ls -l
          echo "Repository cloned and directory listed at $(date)"

      - name: Patch encodeme.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching encodeme.mm at $(date)"
          cat > encodeme.mm << 'EOF'
          @import AVFAudio;
          @import AudioToolbox;
          #include <vector>
          #include <random>

          struct CodecConfig {
            char padding0[0x78];
            AudioChannelLayout* remappingChannelLayout;
            char padding1[0xe0 - 0x80];
            std::vector<char> mRemappingArray;

            CodecConfig() : remappingChannelLayout(nullptr) {}
            ~CodecConfig() {
              if (remappingChannelLayout) {
                free(remappingChannelLayout);
              }
            }
          };

          void OverrideApac(CodecConfig* config) {
            if (config->remappingChannelLayout) {
              config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_HOA_ACN_SN3D | 0x8;
            }
            config->mRemappingArray.resize(0x10000, 0xff);
          }

          int main() {
            std::vector<double> sampleRates = {8000, 16000, 44100, 48000, 96000};
            std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC, kAudioFormatLinearPCM, kAudioFormatMPEG4AAC};
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> formatDist(0, formats.size() - 1);

            for (double sampleRate : sampleRates) {
              AudioFormatID formatID = formats[formatDist(gen)];
              uint32_t channelNum = 1;
              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate
                                                                                       channels:channelNum];
              AudioStreamBasicDescription outputDescription = {
                  .mSampleRate = sampleRate,
                  .mFormatID = formatID,
                  .mFormatFlags = (formatID == kAudioFormatLinearPCM) ? kAudioFormatFlagIsFloat : 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 0,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0};

              AVAudioChannelLayout* channelLayout =
                  [AVAudioChannelLayout layoutWithLayoutTag:kAudioChannelLayoutTag_HOA_ACN_SN3D | 1];

              CodecConfig config;
              AudioChannelLayout* channelLayoutCopy = (AudioChannelLayout*)malloc(sizeof(AudioChannelLayout));
              if (!channelLayoutCopy) {
                fprintf(stderr, "Memory allocation failed for sample rate %.0f\n", sampleRate);
                continue;
              }
              memcpy(channelLayoutCopy, channelLayout.layout, sizeof(AudioChannelLayout));
              config.remappingChannelLayout = channelLayoutCopy;

              OverrideApac(&config);

              NSString* fileName = [NSString stringWithFormat:@"output_%.0f_%u.mp4", sampleRate, formatID];
              NSURL* outUrl = [NSURL fileURLWithPath:fileName];
              ExtAudioFileRef audioFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl, kAudioFileMPEG4Type,
                                                          &outputDescription, config.remappingChannelLayout,
                                                          kAudioFileFlags_EraseFile, &audioFile);
              if (status) {
                fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                free(channelLayoutCopy);
                continue;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                fprintf(stderr, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                ExtAudioFileDispose(audioFile);
                free(channelLayoutCopy);
                continue;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                fprintf(stderr, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                ExtAudioFileDispose(audioFile);
                free(channelLayoutCopy);
                continue;
              }

              float audioBuffer[44100];
              std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
              for (int i = 0; i < 44100; ++i) {
                audioBuffer[i] = dis(gen);
              }
              AudioBufferList audioBufferList = {
                  .mNumberBuffers = 1,
                  .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = sizeof(audioBuffer), .mData = audioBuffer}},
              };
              status = ExtAudioFileWrite(audioFile, sizeof(audioBuffer) / sizeof(audioBuffer[0]), &audioBufferList);
              if (status) {
                fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              status = ExtAudioFileDispose(audioFile);
              if (status) {
                fprintf(stderr, "Error closing file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              free(channelLayoutCopy);
            }
            return 0;
          }
          EOF
          echo "encodeme.mm patched at $(date)"

      - name: Patch fuzzer.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching fuzzer.mm at $(date)"
          cat > fuzzer.mm << 'EOF'
          #import <Foundation/Foundation.h>
          #import <AVFAudio/AVFAudio.h>
          #import <AudioToolbox/AudioToolbox.h>
          #import <os/log.h>
          #include <vector>
          #include <random>
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>
          #include <fcntl.h>
          #include <unistd.h>

          struct CodecConfig {
              char padding0[0x78];
              AudioChannelLayout* remappingChannelLayout;
              char padding1[0xe0 - 0x80];
              std::vector<char> mRemappingArray;

              CodecConfig() : remappingChannelLayout(nullptr) {}
              ~CodecConfig() {
                  if (remappingChannelLayout) {
                      free(remappingChannelLayout);
                  }
              }
          };

          void OverrideApac(CodecConfig* config) {
              if (config->remappingChannelLayout) {
                  config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_Mono;
              }
              config->mRemappingArray.resize(512, 0xff);
          }

          void handleCrash(int sig) {
              FILE* logFile = fopen("fuzzer_crash.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Crash detected: Signal %d at %s", sig, ctime(&now));
                  fclose(logFile);
              }
              fprintf(stderr, "Crash detected: Signal %d\n", sig);
              exit(1);
          }

          NSString* generateFuzzedAudio(NSString* inputPath, bool isMP3) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Generating fuzzed audio at %s", ctime(&now));
              }
              std::vector<double> sampleRates = {44100};
              std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC};
              std::random_device rd;
              std::mt19937 gen(rd());
              std::uniform_int_distribution<> formatDist(0, formats.size() - 1);
              std::uniform_int_distribution<> rateDist(0, sampleRates.size() - 1);

              double sampleRate = sampleRates[rateDist(gen)];
              AudioFormatID formatID = formats[formatDist(gen)];
              uint32_t channelNum = 1;

              if (logFile) {
                  fprintf(logFile, "Params: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                          sampleRate, formatID, channelNum, isMP3);
              }
              fprintf(stderr, "Generating fuzzed audio: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                      sampleRate, formatID, channelNum, isMP3);

              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channelNum];
              AudioStreamBasicDescription outputDesc = {
                  .mSampleRate = sampleRate,
                  .mFormatID = formatID,
                  .mFormatFlags = 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 1024,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0
              };

              AVAudioChannelLayout* channelLayout = [[AVAudioChannelLayout alloc] initWithLayoutTag:kAudioChannelLayoutTag_Mono];
              CodecConfig config;
              AudioChannelLayout* layoutCopy = (AudioChannelLayout*)malloc(sizeof(AudioChannelLayout));
              if (!layoutCopy) {
                  if (logFile) {
                      fprintf(logFile, "Memory allocation failed for rate %.0f\n", sampleRate);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Memory allocation failed for rate %.0f\n", sampleRate);
                  return nil;
              }
              memcpy(layoutCopy, channelLayout.layout, sizeof(AudioChannelLayout));
              config.remappingChannelLayout = layoutCopy;
              OverrideApac(&config);

              NSString* fileName = [NSString stringWithFormat:@"fuzzed_%.0f_%u.%@", sampleRate, formatID, isMP3 ? @"mp3" : @"m4a"];
              NSString* tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
              NSURL* outUrl = [NSURL fileURLWithPath:tempPath];

              if (logFile) {
                  fprintf(logFile, "Creating file at path: %s\n", tempPath.UTF8String);
              }
              fprintf(stderr, "Creating file at path: %s\n", tempPath.UTF8String);

              ExtAudioFileRef audioFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl,
                                                         isMP3 ? kAudioFileMP3Type : kAudioFileM4AType,
                                                         &outputDesc, config.remappingChannelLayout,
                                                         kAudioFileFlags_EraseFile, &audioFile);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting format (rate %.0f, format %u): %x\n", status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              float audioBuffer[1024];
              std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
              for (int i = 0; i < 1024; ++i) {
                  audioBuffer[i] = dis(gen) * 0.5f;
              }
              AudioBufferList bufferList = {
                  .mNumberBuffers = 1,
                  .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = sizeof(audioBuffer), .mData = audioBuffer}}
              };
              status = ExtAudioFileWrite(audioFile, sizeof(audioBuffer) / sizeof(audioBuffer[0]), &bufferList);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              if (logFile) {
                  fclose(logFile);
              }
              return tempPath;
          }

          NSMutableData* generateFuzzedBuffer(NSUInteger len) {
              NSMutableData *buffer = [NSMutableData dataWithLength:len];
              uint8_t *bytes = (uint8_t *)buffer.mutableBytes;

              for (NSUInteger i = 0; i < len; i++) {
                  bytes[i] = rand() % 256;
              }

              int mutations = rand() % 5 + 3;
              for (int i = 0; i < mutations; i++) {
                  NSUInteger offset = rand() % len;
                  bytes[offset] = (rand() % 2) ? 0x00 : 0xFF;
              }

              return buffer;
          }

          void audioQueueCallback(void *userData, AudioQueueRef queue, AudioQueueBufferRef buffer) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "AudioQueue callback at %s", ctime(&now));
              }
              NSMutableData *fuzzedData = generateFuzzedBuffer(buffer->mAudioDataByteSize);
              buffer->mAudioDataByteSize = fuzzedData.length;
              memcpy(buffer->mAudioData, fuzzedData.bytes, fuzzedData.length);

              AudioStreamPacketDescription *packets = NULL;
              UInt32 numPackets = rand() % 5;
              if (numPackets) {
                  packets = (AudioStreamPacketDescription*)malloc(numPackets * sizeof(AudioStreamPacketDescription));
                  for (UInt32 i = 0; i < numPackets; i++) {
                      packets[i].mStartOffset = rand() % buffer->mAudioDataByteSize;
                      packets[i].mDataByteSize = rand() % (buffer->mAudioDataByteSize - packets[i].mStartOffset + 1);
                      packets[i].mVariableFramesInPacket = rand() % 5;
                  }
              }

              OSStatus status = AudioQueueEnqueueBuffer(queue, buffer, numPackets, packets);
              if (status != noErr) {
                  if (logFile) {
                      fprintf(logFile, "Enqueue failed: %d\n", (int)status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Enqueue failed: %d\n", (int)status);
              }

              free(packets);
              if (logFile) {
                  fclose(logFile);
              }
          }

          void fuzzAudioQueue(AudioQueueRef queue) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              AudioQueueParameterID param = kAudioQueueParam_PlayRate;
              AudioQueueParameterValue rate = ((float)((int)rand() % 200 - 50)) / 50.0f;
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Setting play rate: %f at %s", rate, ctime(&now));
                  fclose(logFile);
              }
              AudioQueueSetParameter(queue, param, rate);
          }

          void fuzzAVAudioPlayer(AVAudioPlayer *player) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              float rate = ((float)((int)rand() % 200 - 50)) / 100.0f;
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Fuzzed rate: %f at %s", rate, ctime(&now));
              }
              fprintf(stderr, "-> Fuzzed rate: %f\n", rate);
              player.rate = rate;

              NSTimeInterval time = ((double)(rand() % 500)) / 100.0;
              if (logFile) {
                  fprintf(logFile, "Fuzzed time: %f\n", time);
              }
              fprintf(stderr, "-> Fuzzed time: %f\n", time);
              player.currentTime = time;

              if (rand() % 2) {
                  if (logFile) {
                      fprintf(logFile, "Playing and stopping player\n");
                      fclose(logFile);
                  }
                  [player play];
                  usleep(rand() % 20000);
                  [player stop];
              } else if (logFile) {
                  fclose(logFile);
              }
          }

          void fuzzMediaToolbox(NSString *path, NSError **err) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "MediaToolbox fuzzing requires headers at %s", ctime(&now));
                  fclose(logFile);
              }
              fprintf(stderr, "MediaToolbox fuzzing requires headers\n");
          }

          int main(int argc, char *argv[]) {
              @autoreleasepool {
                  FILE* logFile = fopen("fuzzer_detail.log", "a");
                  if (logFile) {
                      time_t now = time(NULL);
                      fprintf(logFile, "Starting fuzzing at %s", ctime(&now));
                  }
                  signal(SIGSEGV, handleCrash);
                  signal(SIGABRT, handleCrash);
                  signal(SIGILL, handleCrash);

                  NSString *inputPath = @"output.m4a";
                  if (argc > 1) {
                      inputPath = @(argv[1]);
                      if (logFile) {
                          fprintf(logFile, "Using input path: %s\n", inputPath.UTF8String);
                      }
                  }

                  int iterations = 5;
                  if (argc > 2) {
                      iterations = atoi(argv[2]);
                      if (logFile) {
                          fprintf(logFile, "Setting iterations: %d\n", iterations);
                      }
                  }

                  for (int i = 0; i < iterations; i++) {
                      if (logFile) {
                          time_t now = time(NULL);
                          fprintf(logFile, "Iteration %d/%d at %s", i + 1, iterations, ctime(&now));
                      }
                      fprintf(stderr, "Iteration %d/%d\n", i + 1, iterations);

                      bool isMP3 = false;
                      NSString *tempPath = generateFuzzedAudio(inputPath, isMP3);
                      if (!tempPath) {
                          if (logFile) {
                              fprintf(logFile, "Failed to generate fuzzed audio\n");
                          }
                          fprintf(stderr, "Failed to generate fuzzed audio\n");
                          continue;
                      }

                      AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:tempPath] error:nil];
                      if (player) {
                          player.enableRate = YES;
                          fuzzAVAudioPlayer(player);
                          [player play];
                          usleep(rand() % 50000);
                          [player stop];
                      } else {
                          if (logFile) {
                              fprintf(logFile, "Player init failed for %s\n", tempPath.UTF8String);
                          }
                          fprintf(stderr, "Player init failed for %s\n", tempPath.UTF8String);
                      }

                      AudioStreamBasicDescription desc = {
                          .mSampleRate = 44100,
                          .mFormatID = kAudioFormatLinearPCM,
                          .mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked,
                          .mBitsPerChannel = 16,
                          .mChannelsPerFrame = 1,
                          .mFramesPerPacket = 1,
                          .mBytesPerFrame = 2,
                          .mBytesPerPacket = 2
                      };
                      AudioQueueRef queue;
                      OSStatus status = AudioQueueNewOutput(&desc, audioQueueCallback, NULL, CFRunLoopGetCurrent(), kCFRunLoopCommonModes, 0, &queue);
                      if (status != noErr) {
                          if (logFile) {
                              fprintf(logFile, "Queue creation failed: %d\n", (int)status);
                          }
                          fprintf(stderr, "Queue creation failed: %d\n", (int)status);
                          continue;
                      }

                      for (int j = 0; j < 3; j++) {
                          AudioQueueBufferRef buffer;
                          UInt32 size = rand() % 100000 + 500;
                          if (AudioQueueAllocateBuffer(queue, size, &buffer) == noErr) {
                              audioQueueCallback(NULL, queue, buffer);
                          }
                      }

                      fuzzAudioQueue(queue);
                      AudioQueueStart(queue, NULL);
                      usleep(rand() % 50000);
                      AudioQueueStop(queue, true);
                      AudioQueueDispose(queue, true);

                      fuzzMediaToolbox(tempPath, nil);

                      [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];

                      if (logFile) {
                          fprintf(logFile, "Completed iteration %d\n", i + 1);
                      }
                      fprintf(stderr, "Completed iteration %d\n", i + 1);
                  }

                  if (logFile) {
                      time_t now = time(NULL);
                      fprintf(logFile, "Fuzzing completed at %s", ctime(&now));
                      fclose(logFile);
                  }
                  fprintf(stderr, "Fuzzing completed\n");
              }
              return 0;
          }
          EOF
          echo "fuzzer.mm patched at $(date)"

      - name: Cache FFmpeg
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/ffmpeg
          key: ffmpeg-${{ runner.os }}-2025-06
          restore-keys: ffmpeg-${{ runner.os }}-

      - name: Install FFmpeg
        run: |
          echo "Installing FFmpeg at $(date)"
          if ! command -v ffmpeg &> /dev/null; then
            brew install ffmpeg
          else
            echo "FFmpeg already installed"
            ffmpeg -version
          fi
          echo "FFmpeg installed at $(date)"

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: Verify Xcode and clang version
        run: |
          echo "Verifying Xcode and clang versions at $(date)"
          xcodebuild -version
          clang++ --version
          xcrun --sdk macosx --show-sdk-path
          echo "Verification completed at $(date)"

      - name: Check system resources
        run: |
          echo "Checking system resources at $(date)"
          df -h
          system_profiler SPHardwareDataType
          echo "System resource check completed at $(date)"

      - name: Verify source files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Verifying files at $(date)"
          for file in encodeme.mm fuzzer.mm; do
            if [ -f "$file" ] && [ -r "$file" ]; then
              echo "$file found and readable"
              ls -l "$file"
            else
              echo "Error: $file not found or not readable"
              ls -l
              exit 1
            fi
          done
          echo "File verification completed at $(date)"

      - name: Compile encodeme
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling encodeme.mm at $(date)"
          clang++ -g -Os -std=c++2b -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot $(xcrun --sdk macosx --show-sdk-path) -framework AVFAudio -framework AudioToolbox encodeme.mm -o encodeme
          if [ $? -eq 0 ]; then
            echo "Compilation completed successfully"
            ls -l encodeme || echo "Compiled binary 'encodeme' not found"
            BINARY_SIZE=$(stat -f %z encodeme 2>/dev/null || stat -c %s encodeme 2>/dev/null)
            echo "Binary size: $BINARY_SIZE bytes"
          else
            echo "Compilation failed"
            exit 1
          fi

      - name: Compile fuzzer
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling fuzzer.mm at $(date)"
          clang++ -g -Os -std=c++2b -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot $(xcrun --sdk macosx --show-sdk-path) -framework AVFAudio -framework AudioToolbox -framework Foundation fuzzer.mm -o fuzzer
          if [ $? -eq 0 ]; then
            echo "Compilation successful"
            ls -l fuzzer || echo "Compiled binary 'fuzzer' not found"
            BINARY_SIZE=$(stat -f %z fuzzer 2>/dev/null || stat -c %s fuzzer 2>/dev/null)
            echo "Binary size: $BINARY_SIZE bytes"
          else
            echo "Compilation failed"
            exit 1
          fi

      - name: Run encodeme
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running encodeme at $(date)"
          chmod +x encodeme
          ./encodeme
          if [ $? -eq 0 ]; then
            echo "encodeme executed successfully"
            ls -l output_*.mp4 || echo "No output files found"
          else
            echo "encodeme execution failed"
            exit 1
          fi

      - name: Convert MP4 to MP3
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Converting MP4 files to MP3 at $(date)"
          for file in output_*.mp4; do
            if [ -f "$file" ]; then
              mp3_file="${file%.mp4}.mp3"
              ffmpeg -i "$file" -c:a mp3 -b:a 128k -ac 1 "$mp3_file"
              if [ $? -eq 0 ]; then
                echo "Converted $file to $mp3_file successfully"
              else
                echo "Conversion of $file failed"
                exit 1
              fi
            else
              echo "No MP4 files found for conversion"
            fi
          done
          echo "Conversion completed at $(date)"

      - name: Run fuzzer
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running fuzzer at $(date)"
          chmod +x fuzzer
          for file in output_*.mp4; do
            if [ -f "$file" ]; then
              timeout 300 ./fuzzer "$file" 5 > "fuzzer_$(basename "$file" .mp4).log" 2>&1 || true
              if [ $? -eq 0 ]; then
                echo "fuzzer executed successfully on $file"
              else
                echo "fuzzer execution failed or timed out on $file"
                cat "fuzzer_$(basename "$file" .mp4).log"
              fi
            else
              echo "No MP4 files found for fuzzing"
            fi
          done
          ls -lh fuzzer_*.log fuzzer_detail.log fuzzer_crash.log 2>/dev/null || echo "One or more log files not found"

      - name: Collect system logs
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Collecting system logs at $(date)"
          if log show --predicate '(subsystem == "com.apple.CrashReporter") OR (eventType == "error" OR eventType == "fault") OR (eventMessage CONTAINS[c] "crash")' --info --error --last 15m > system_fuzzer.log 2>&1; then
            echo "System logs collected successfully"
            ls -lh system_fuzzer.log
          else
            echo "Failed to collect system logs, relying on fuzzer logs"
            echo "System log collection failed at $(date)" > system_fuzzer.log
            ls -lh system_fuzzer.log
          fi
          for log in fuzzer_detail.log fuzzer_crash.log; do
            if [ -f "$log" ]; then
              echo "$log found, size: $(stat -f %z "$log" 2>/dev/null || stat -c %s "$log" 2>/dev/null) bytes"
            else
              echo "$log not found"
            fi
          done

      - name: Collect crash reports
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Collecting crash reports at $(date)"
          mkdir -p crash_reports
          cp -r ~/Library/Logs/DiagnosticReports/*.crash crash_reports/ 2>/dev/null || echo "No crash reports found in ~/Library/Logs/DiagnosticReports"
          cp -r /Library/Logs/DiagnosticReports/*.crash crash_reports/ 2>/dev/null || echo "No crash reports found in /Library/Logs/DiagnosticReports"
          ls -lh crash_reports/ 2>/dev/null || echo "No crash reports copied"

      - name: Verify generated files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Checking for generated files at $(date)"
          for file in output_*.mp4 output_*.mp3; do
            if [ -f "$file" ]; then
              FILE_SIZE=$(stat -f %z "$file" 2>/dev/null || stat -c %s "$file")
              echo "$file size: $FILE_SIZE bytes"
              if [ "$FILE_SIZE" -eq 0 ]; then
                echo "Error: $file is 0 bytes"
                exit 1
              fi
              if ! ffprobe -i "$file" -show_format -show_streams -print_format json 2>/dev/null; then
                echo "Error: ffprobe failed for $file"
                exit 1
              fi
            else
              echo "$file not found"
            fi
          done
          echo "Checking for fuzzed files at $(date)"
          ls -lh /tmp/fuzzed_* 2>/dev/null || echo "No fuzzed files found"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: audio-and-log-files
          path: |
            AppleTest/apple-positional-audio-codec-invalid-header-main/output_*.mp4
            AppleTest/apple-positional-audio-codec-invalid-header-main/output_*.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer_*.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer_detail.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer_crash.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/system_fuzzer.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/crash_reports/*.crash
            /tmp/fuzzed_*.m4a
          retention-days: 7
          if-no-files-found: warn
