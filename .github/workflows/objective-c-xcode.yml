name: Generate and Fuzz Audio Files

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering

jobs:
  build-and-generate:
    runs-on: macos-latest
    timeout-minutes: 30 # Prevent hanging steps

    steps:
      # Clone the repository
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          echo "Listing directory contents at $(date)"
          ls -l
          echo "Repository cloned and directory listed at $(date)"

      # Patch encodeme.mm for 10-second M4A
      - name: Patch encodeme.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching encodeme.mm at $(date)"
          cat > encodeme.mm << EOF
          @import AVFAudio;
          @import AudioToolbox;
          #include <cmath>
          int main() {
              uint32_t channelNum = 1;
              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100
                                                                               channels:channelNum];
              AVAudioChannelLayout* channelLayout =
                  [AVAudioChannelLayout layoutWithLayoutTag:kAudioChannelLayoutTag_Mono];
              const int sampleRate = 44100;
              const int durationSeconds = 10;
              const int totalSamples = sampleRate * durationSeconds;
              const int samplesPerBuffer = 1024;
              float* audioBuffer = (float*)malloc(samplesPerBuffer * sizeof(float));
              AudioStreamBasicDescription m4aDescription{
                  .mSampleRate = 44100,
                  .mFormatID = kAudioFormatMPEG4AAC,
                  .mFormatFlags = 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 1024,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0
              };
              NSURL* m4aUrl = [NSURL fileURLWithPath:@"output.m4a"];
              ExtAudioFileRef m4aFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)m4aUrl, kAudioFileM4AType,
                                                          &m4aDescription, channelLayout.layout,
                                                          kAudioFileFlags_EraseFile, &m4aFile);
              if (status) {
                  fprintf(stderr, "error creating M4A file: %x\n", status);
                  free(audioBuffer);
                  return 1;
              }
              status = ExtAudioFileSetProperty(m4aFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                  fprintf(stderr, "error setting M4A client format: %x\n", status);
                  ExtAudioFileDispose(m4aFile);
                  free(audioBuffer);
                  return 1;
              }
              status = ExtAudioFileSetProperty(m4aFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                  fprintf(stderr, "error setting M4A channel layout: %x\n", status);
                  ExtAudioFileDispose(m4aFile);
                  free(audioBuffer);
                  return 1;
              }
              for (int i = 0; i < totalSamples; i += samplesPerBuffer) {
                  int samplesToWrite = (i + samplesPerBuffer <= totalSamples) ? samplesPerBuffer : (totalSamples - i);
                  for (int j = 0; j < samplesToWrite; j++) {
                      audioBuffer[j] = sin(2 * M_PI * 440 * (i + j) / sampleRate) * 0.5f;
                  }
                  AudioBufferList audioBufferList{
                      .mNumberBuffers = 1,
                      .mBuffers = {
                          {
                              .mNumberChannels = 1,
                              .mDataByteSize = static_cast<UInt32>(samplesToWrite * sizeof(float)),
                              .mData = audioBuffer,
                          },
                      },
                  };
                  status = ExtAudioFileWrite(m4aFile, samplesToWrite, &audioBufferList);
                  if (status) {
                      fprintf(stderr, "error writing M4A audio: %x\n", status);
                      ExtAudioFileDispose(m4aFile);
                      free(audioBuffer);
                      return 1;
                  }
              }
              free(audioBuffer);
              status = ExtAudioFileDispose(m4aFile);
              if (status) {
                  fprintf(stderr, "error closing M4A file: %x\n", status);
                  return 1;
              }
              return 0;
          }
          EOF
          echo "encodeme.mm patched at $(date)"

      # Patch fuzzer.mm
      - name: Patch fuzzer.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching fuzzer.mm at $(date)"
          cat > fuzzer.mm << 'EOF'
          #import <Foundation/Foundation.h>
          #import <AVFAudio/AVFAudio.h>
          #import <AudioToolbox/AudioToolbox.h>
          #import <os/log.h>
          #include <vector>
          #include <random>
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>
          #include <fcntl.h>
          #include <unistd.h>

          struct CodecConfig {
              char padding0[0x78];
              AudioChannelLayout* remappingChannelLayout;
              char padding1[0xe0 - 0x80];
              std::vector<char> mRemappingArray;

              CodecConfig() : remappingChannelLayout(nullptr) {}
              ~CodecConfig() {
                  if (remappingChannelLayout) {
                      free(remappingChannelLayout);
                  }
              }
          };

          void OverrideApac(CodecConfig* config) {
              if (config->remappingChannelLayout) {
                  config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_Mono;
              }
              config->mRemappingArray.resize(512, 0xff);
          }

          void handleCrash(int sig) {
              FILE* logFile = fopen("fuzzer_crash.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Crash detected: Signal %d at %s", sig, ctime(&now));
                  fclose(logFile);
              }
              fprintf(stderr, "Crash detected: Signal %d\n", sig);
              exit(1);
          }

          NSString* generateFuzzedAudio(NSString* inputPath, bool isMP3) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Generating fuzzed audio at %s", ctime(&now));
              }
              std::vector<double> sampleRates = {44100};
              std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC};
              std::random_device rd;
              std::mt19937 gen(rd());
              std::uniform_int_distribution<> formatDist(0, formats.size() - 1);
              std::uniform_int_distribution<> rateDist(0, sampleRates.size() - 1);

              double sampleRate = sampleRates[rateDist(gen)];
              AudioFormatID formatID = formats[formatDist(gen)];
              uint32_t channelNum = 1;

              if (logFile) {
                  fprintf(logFile, "Params: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                          sampleRate, formatID, channelNum, isMP3);
              }
              fprintf(stderr, "Generating fuzzed audio: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                      sampleRate, formatID, channelNum, isMP3);

              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channelNum];
              AudioStreamBasicDescription outputDesc = {
                  .mSampleRate = sampleRate,
                  .mFormatID = formatID,
                  .mFormatFlags = 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 1024,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0
              };

              AVAudioChannelLayout* channelLayout = [[AVAudioChannelLayout alloc] initWithLayoutTag:kAudioChannelLayoutTag_Mono];
              CodecConfig config;
              AudioChannelLayout* layoutCopy = (AudioChannelLayout*)malloc(sizeof(AudioChannelLayout));
              if (!layoutCopy) {
                  if (logFile) {
                      fprintf(logFile, "Memory allocation failed for rate %.0f\n", sampleRate);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Memory allocation failed for rate %.0f\n", sampleRate);
                  return nil;
              }
              memcpy(layoutCopy, channelLayout.layout, sizeof(AudioChannelLayout));
              config.remappingChannelLayout = layoutCopy;
              OverrideApac(&config);

              NSString* fileName = [NSString stringWithFormat:@"fuzzed_%.0f_%u.%@", sampleRate, formatID, isMP3 ? @"mp3" : @"m4a"];
              NSString* tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
              NSURL* outUrl = [NSURL fileURLWithPath:tempPath];

              if (logFile) {
                  fprintf(logFile, "Creating file at path: %s\n", tempPath.UTF8String);
              }
              fprintf(stderr, "Creating file at path: %s\n", tempPath.UTF8String);

              ExtAudioFileRef audioFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl,
                                                         isMP3 ? kAudioFileMP3Type : kAudioFileM4AType,
                                                         &outputDesc, config.remappingChannelLayout,
                                                         kAudioFileFlags_EraseFile, &audioFile);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              float audioBuffer[1024];
              std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
              for (int i = 0; i < 1024; ++i) {
                  audioBuffer[i] = dis(gen) * 0.5f;
              }
              AudioBufferList bufferList = {
                  .mNumberBuffers = 1,
                  .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = sizeof(audioBuffer), .mData = audioBuffer}}
              };
              status = ExtAudioFileWrite(audioFile, sizeof(audioBuffer) / sizeof(audioBuffer[0]), &bufferList);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              if (logFile) {
                  fclose(logFile);
              }
              return tempPath;
          }

          NSMutableData* generateFuzzedBuffer(NSUInteger len) {
              NSMutableData *buffer = [NSMutableData dataWithLength:len];
              uint8_t *bytes = (uint8_t *)buffer.mutableBytes;

              for (NSUInteger i = 0; i < len; i++) {
                  bytes[i] = rand() % 256;
              }

              int mutations = rand() % 5 + 5;
              for (int i = 0; i < mutations; ++i) {
                  NSUInteger err = rand() % len;
                  bytes[i] = (rand() % 2) ? 0x00 : 0xFF;
              }

              return buffer;
          }

          void audioQueueCallback(void *userdata, void *RefCallbackQueue, AudioQueueRefQueueRef buffer) {
              FILE *out = fopen("fuzzer_detail.log", "a");
              if (out) {
                  time_t now = time(NULL);
                  fprintf(out, "AudioQueueCallback at %d\n", buffer ctime(&now));
                  fclose(out);
              }

              NSMutableData *fuzzedData = generateFuzzedData(buffer->mAudioDataBytesCapacity);
              buffer->mAudioDataBytesSize = fuzzedData.lengthBytesize;
              memcpy(buffer->fuzzedDataBytes, data->fuzzedBytes, data->lengthBytes);

              AudioStreamBasicDescription* packets = NULL;

              UInt32_t numPackets = rand() % 256;

              if (numPackets) {
                  packets = (AudioStreamBufferDescription*)malloc(numPackets * sizeof(numPackets));
                  for (UInt32_t i = 0; i < numPackets; i++) {
                      packets[i].mStartOffset = rand() % numPackets;
                      packets[i].mByteSize = rand() % (buffer->mAudioDataByteSize - packets[i].mStartOffset + 1);
                      packets[i].mVariableFramesInPacket = rand() % 5;
                  }
              }

              OSStatus status = (OSStatus) audioQueueEnqueueWithBuffer(audioBuffer, buffer, packets);
              if (!status)
              {
                  if (out)
                      fprintf(out, "Failed to start audio queue: %f", status);
                      fclose(out);
                  fprintf(stderr, "Failed to start audio queue: %d\n", (int)status);
              }

              free(packets); out(fout);
          }

          void audioQueueFuzzer(AudioQueueFuzzerRef fuzzerRef) {
              FILE *outfuzzer = fopen("fuzzer_log_detail.log", "a");
              AudioQueueRefParameterID parameter = kAudioQueueParameter_Fuzzer;
              AudioQueueParameterValue value = ((float)rand() % 200 - 50) / 50.0f;
              if (outfuzzer) {
                  time_t now = time(NULL);
                  fprintf(outfuzzer, "Setting rate: %f at %s", value, ctime(&now));
                  fclose(outfuzzer);
              }
              AudioQueueSetParameter(fuzzerRef, parameter, value);
          }

          void fuzzAVAudioPlayer(AVAudioPlayer *playerAudio) AVAudio {
              FILE *outfileFile = fopen("fuzzer_log_detail.txt", "f");
              float rateFuzzer = ((float)(rand() % 256) - 50) / 100.0fuzzer);
              if (outfilefuzzer)) {
                  time_t now = time(NULL);
                  fprintf(outfilefuzzer, "Fuzzed rate: %f at %s", rateFuzzer, ctime(&now));
                  fclose(outfilefuzzer);
              }
              fprintf(stderrfuzzer, "-> Fuzzed rate: %f\n", rateFuzzer);
              playerAudio->rateFuzzer = rate; Fuzzer;

              NSTimeInterval timeFuzzer = ((double)(rand() % 500) / 100.0);
              if (fuzzer(outfile)) {
                  fprintf(outfilefuzzer, "Fuzzed time: %f\n", timeFuzzer);
                  fclose(outfile);
              }
              fprintf(stderrfuzzer, "-> Fuzzed time: %f\n", timeFuzzer);
              playerAudio->currentTimeFuzzer = timeFuzzer;

              f (rand(f % 2)) f
                  f(outfilefuzzer) {
                      fprintf(outfilefuzzer, "Playing audio playerAudioPlayer\n");
                      fclose(outfilefuzzer);
                  fuzzer)
                  playerAudio.play;
                  usleep(rand() % 50000);
                  playerAudioPlayer.stop;
              fuzzer) else if (outfile(fuzzer)) {
                  fclose(outfilefuzzer);
          }

          void fuzzMedia
