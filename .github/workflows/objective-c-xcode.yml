name: Generate and Fuzz Audio Files

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering

jobs:
  build-and-generate:
    runs-on: macos-latest
    timeout-minutes: 30 # Prevent hanging steps

    steps:
      # Clone the repository
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          echo "Listing directory contents at $(date)"
          ls -l
          echo "Repository cloned and directory listed at $(date)"

      # Patch encodeme.mm for 10-second M4A
      - name: Patch encodeme.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching encodeme.mm at $(date)"
          cat > encodeme.mm << EOF
          @import AVFAudio;
          @import AudioToolbox;
          #include <cmath>
          int main() {
              uint32_t channelNum = 1;
              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100
                                                                               channels:channelNum];
              AVAudioChannelLayout* channelLayout =
                  [AVAudioChannelLayout layoutWithLayoutTag:kAudioChannelLayoutTag_Mono];
              const int sampleRate = 44100;
              const int durationSeconds = 10;
              const int totalSamples = sampleRate * durationSeconds;
              const int samplesPerBuffer = 1024;
              float* audioBuffer = (float*)malloc(samplesPerBuffer * sizeof(float));
              AudioStreamBasicDescription m4aDescription{
                  .mSampleRate = 44100,
                  .mFormatID = kAudioFormatMPEG4AAC,
                  .mFormatFlags = 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 1024,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0
              };
              NSURL* m4aUrl = [NSURL fileURLWithPath:@"output.m4a"];
              ExtAudioFileRef m4aFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)m4aUrl, kAudioFileM4AType,
                                                          &m4aDescription, channelLayout.layout,
                                                          kAudioFileFlags_EraseFile, &m4aFile);
              if (status) {
                  fprintf(stderr, "error creating M4A file: %x\n", status);
                  free(audioBuffer);
                  return 1;
              }
              status = ExtAudioFileSetProperty(m4aFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                  fprintf(stderr, "error setting M4A client format: %x\n", status);
                  ExtAudioFileDispose(m4aFile);
                  free(audioBuffer);
                  return 1;
              }
              status = ExtAudioFileSetProperty(m4aFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                  fprintf(stderr, "error setting M4A channel layout: %x\n", status);
                  ExtAudioFileDispose(m4aFile);
                  free(audioBuffer);
                  return 1;
              }
              for (int i = 0; i < totalSamples; i += samplesPerBuffer) {
                  int samplesToWrite = (i + samplesPerBuffer <= totalSamples) ? samplesPerBuffer : (totalSamples - i);
                  for (int j = 0; j < samplesToWrite; j++) {
                      audioBuffer[j] = sin(2 * M_PI * 440 * (i + j) / sampleRate) * 0.5f;
                  }
                  AudioBufferList audioBufferList{
                      .mNumberBuffers = 1,
                      .mBuffers = {
                          {
                              .mNumberChannels = 1,
                              .mDataByteSize = static_cast<UInt32>(samplesToWrite * sizeof(float)),
                              .mData = audioBuffer,
                          },
                      },
                  };
                  status = ExtAudioFileWrite(m4aFile, samplesToWrite, &audioBufferList);
                  if (status) {
                      fprintf(stderr, "error writing M4A audio: %x\n", status);
                      ExtAudioFileDispose(m4aFile);
                      free(audioBuffer);
                      return 1;
                  }
              }
              free(audioBuffer);
              status = ExtAudioFileDispose(m4aFile);
              if (status) {
                  fprintf(stderr, "error closing M4A file: %x\n", status);
                  return 1;
              }
              return 0;
          }
          EOF
          echo "encodeme.mm patched at $(date)"

      # Patch fuzzer.mm
      - name: Patch fuzzer.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching fuzzer.mm at $(date)"
          cat > fuzzer.mm << 'EOF'
          #import <Foundation/Foundation.h>
          #import <AVFAudio/AVFAudio.h>
          #import <AudioToolbox/AudioToolbox.h>
          #import <os/log.h>
          #include <vector>
          #include <random>
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>
          #include <fcntl.h>
          #include <unistd.h>

          struct CodecConfig {
              char padding0[0x78];
              AudioChannelLayout* remappingChannelLayout;
              char padding1[0xe0 - 0x80];
              std::vector<char> mRemappingArray;

              CodecConfig() : remappingChannelLayout(nullptr) {}
              ~CodecConfig() {
                  if (remappingChannelLayout) {
                      free(remappingChannelLayout);
                  }
              }
          };

          void OverrideApac(CodecConfig* config) {
              if (config->remappingChannelLayout) {
                  config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_Mono;
              }
              config->mRemappingArray.resize(512, 0xff);
          }

          void handleCrash(int sig) {
              FILE* logFile = fopen("fuzzer_crash.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Crash detected: Signal %d at %s", sig, ctime(&now));
                  fclose(logFile);
              }
              fprintf(stderr, "Crash detected: Signal %d\n", sig);
              exit(1);
          }

          NSString* generateFuzzedAudio(NSString* inputPath, bool isMP3) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Generating fuzzed audio at %s", ctime(&now));
              }
              std::vector<double> sampleRates = {44100};
              std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC};
              std::random_device rd;
              std::mt19937 gen(rd());
              std::uniform_int_distribution<> formatDist(0, formats.size() - 1);
              std::uniform_int_distribution<> rateDist(0, sampleRates.size() - 1);

              double sampleRate = sampleRates[rateDist(gen)];
              AudioFormatID formatID = formats[formatDist(gen)];
              uint32_t channelNum = 1;

              if (logFile) {
                  fprintf(logFile, "Params: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                          sampleRate, formatID, channelNum, isMP3);
              }
              fprintf(stderr, "Generating fuzzed audio: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                      sampleRate, formatID, channelNum, isMP3);

              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channelNum];
              AudioStreamBasicDescription outputDesc = {
                  .mSampleRate = sampleRate,
                  .mFormatID = formatID,
                  .mFormatFlags = 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 1024,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0
              };

              AVAudioChannelLayout* channelLayout = [[AVAudioChannelLayout alloc] initWithLayoutTag:kAudioChannelLayoutTag_Mono];
              CodecConfig config;
              AudioChannelLayout* layoutCopy = (AudioChannelLayout*)malloc(sizeof(AudioChannelLayout));
              if (!layoutCopy) {
                  if (logFile) {
                      fprintf(logFile, "Memory allocation failed for rate %.0f\n", sampleRate);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Memory allocation failed for rate %.0f\n", sampleRate);
                  return nil;
              }
              memcpy(layoutCopy, channelLayout.layout, sizeof(AudioChannelLayout));
              config.remappingChannelLayout = layoutCopy;
              OverrideApac(&config);

              NSString* fileName = [NSString stringWithFormat:@"fuzzed_%.0f_%u.%@", sampleRate, formatID, isMP3 ? @"mp3" : @"m4a"];
              NSString* tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
              NSURL* outUrl = [NSURL fileURLWithPath:tempPath];

              if (logFile) {
                  fprintf(logFile, "Creating file at path: %s\n", tempPath.UTF8String);
              }
              fprintf(stderr, "Creating file at path: %s\n", tempPath.UTF8String);

              ExtAudioFileRef audioFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl,
                                                         isMP3 ? kAudioFileMP3Type : kAudioFileM4AType,
                                                         &outputDesc, config.remappingChannelLayout,
                                                         kAudioFileFlags_EraseFile, &audioFile);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting format (rate %.0f, format %u): %x\n", status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              float audioBuffer[1024];
              std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
              for (int i = 0; i < 1024; ++i) {
                  audioBuffer[i] = dis(gen) * 0.5f;
              }
              AudioBufferList bufferList = {
                  .mNumberBuffers = 1,
                  .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = sizeof(audioBuffer), .mData = audioBuffer}}
              };
              status = ExtAudioFileWrite(audioFile, sizeof(audioBuffer) / sizeof(audioBuffer[0]), &bufferList);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              if (logFile) {
                  fclose(logFile);
              }
              return tempPath;
          }

          NSMutableData* generateFuzzedBuffer(NSUInteger len) {
              NSMutableData *buffer = [NSMutableData dataWithLength:len];
              uint8_t *bytes = (uint8_t *)buffer.mutableBytes;

              for (NSUInteger i = 0; i < len; i++) {
                  bytes[i] = rand() % 256;
              }

              int mutations = rand() % 5 + 3;
              for (int i = 0; i < mutations; i++) {
                  NSUInteger offset = rand() % len;
                  bytes[offset] = (rand() % 2) ? 0x00 : 0xFF;
              }

              return buffer;
          }

          void audioQueueCallback(void *userData, AudioQueueRef queue, AudioQueueBufferRef buffer) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "AudioQueue callback at %s", ctime(&now));
              }
              NSMutableData *fuzzedData = generateFuzzedBuffer(buffer->mAudioDataByteSize);
              buffer->mAudioDataByteSize = fuzzedData.length;
              memcpy(buffer->mAudioData, fuzzedData.bytes, fuzzedData.length);

              AudioStreamPacketDescription *packets = NULL;
              UInt32 numPackets = rand() % 5;
              if (numPackets) {
                  packets = (AudioStreamPacketDescription*)malloc(numPackets * sizeof(AudioStreamPacketDescription));
                  for (UInt32 i = 0; i < numPackets; i++) {
                      packets[i].mStartOffset = rand() % buffer->mAudioDataByteSize;
                      packets[i].mDataByteSize = rand() % (buffer->mAudioDataByteSize - packets[i].mStartOffset + 1);
                      packets[i].mVariableFramesInPacket = rand() % 5;
                  }
              }

              OSStatus status = AudioQueueEnqueueBuffer(queue, buffer, numPackets, packets);
              if (status != noErr) {
                  if (logFile) {
                      fprintf(logFile, "Enqueue failed: %d\n", (int)status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Enqueue failed: %d\n", (int)status);
              }

              free(packets);
              if (logFile) {
                  fclose(logFile);
              }
          }

          void fuzzAudioQueue(AudioQueueRef queue) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              AudioQueueParameterID param = kAudioQueueParam_PlayRate;
              AudioQueueParameterValue rate = ((float)((int)rand() % 200 - 50)) / 50.0f;
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Setting play rate: %f at %s", rate, ctime(&now));
                  fclose(logFile);
              }
              AudioQueueSetParameter(queue, param, rate);
          }

          void fuzzAVAudioPlayer(AVAudioPlayer *player) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              float rate = ((float)((int)rand() % 200 - 50)) / 100.0f;
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "Fuzzed rate: %f at %s", rate, ctime(&now));
              }
              fprintf(stderr, "-> Fuzzed rate: %f\n", rate);
              player.rate = rate;

              NSTimeInterval time = ((double)(rand() % 500)) / 100.0;
              if (logFile) {
                  fprintf(logFile, "Fuzzed time: %f\n", time);
              }
              fprintf(stderr, "-> Fuzzed time: %f\n", time);
              player.currentTime = time;

              if (rand() % 2) {
                  if (logFile) {
                      fprintf(logFile, "Playing and stopping player\n");
                      fclose(logFile);
                  }
                  [player play];
                  usleep(rand() % 20000);
                  [player stop];
              } else if (logFile) {
                  fclose(logFile);
              }
          }

          void fuzzMediaToolbox(NSString *path, NSError **err) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  time_t now = time(NULL);
                  fprintf(logFile, "MediaToolbox fuzzing requires headers at %s", ctime(&now));
                  fclose(logFile);
              }
              fprintf(stderr, "MediaToolbox fuzzing requires headers\n");
          }

          int main(int argc, char *argv[]) {
              @autoreleasepool {
                  FILE* logFile = fopen("fuzzer_detail.log", "a");
                  if (logFile) {
                      time_t now = time(NULL);
                      fprintf(logFile, "Starting fuzzing at %s", ctime(&now));
                  }
                  signal(SIGSEGV, handleCrash);
                  signal(SIGABRT, handleCrash);
                  signal(SIGILL, handleCrash);

                  NSString *inputPath = @"output.m4a";
                  if (argc > 1) {
                      inputPath = @(argv[1]);
                      if (logFile) {
                          fprintf(logFile, "Using input path: %s\n", inputPath.UTF8String);
                      }
                  }

                  int iterations = 5;
                  if (argc > 2) {
                      iterations = atoi(argv[2]);
                      if (logFile) {
                          fprintf(logFile, "Setting iterations: %d\n", iterations);
                      }
                  }

                  for (int i = 0; i < iterations; i++) {
                      if (logFile) {
                          time_t now = time(NULL);
                          fprintf(logFile, "Iteration %d/%d at
