name: Generate and Fuzz Audio Files

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: # Allows manual triggering

jobs:
  build-and-generate:
    runs-on: macos-latest
    timeout-minutes: 30 # Prevent hanging steps

    steps:
      # Clone the repository
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          echo "Listing directory contents at $(date)"
          ls -l
          echo "Repository cloned and directory listed at $(date)"

      # Patch encodeme.mm for 10-second M4A
      - name: Patch encodeme.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching encodeme.mm at $(date)"
          cat > encodeme.mm << EOF
          @import AVFAudio;
          @import AudioToolbox;
          #include <cmath>
          int main() {
              uint32_t channelNum = 1;
              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:44100
                                                                               channels:channelNum];
              AVAudioChannelLayout* channelLayout =
                  [AVAudioChannelLayout layoutWithLayoutTag:kAudioChannelLayoutTag_Mono];
              const int sampleRate = 44100;
              const int durationSeconds = 10;
              const int totalSamples = sampleRate * durationSeconds;
              const int samplesPerBuffer = 1024;
              float* audioBuffer = (float*)malloc(samplesPerBuffer * sizeof(float));
              AudioStreamBasicDescription m4aDescription{
                  .mSampleRate = 44100,
                  .mFormatID = kAudioFormatMPEG4AAC,
                  .mFormatFlags = 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 1024,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0
              };
              NSURL* m4aUrl = [NSURL fileURLWithPath:@"output.m4a"];
              ExtAudioFileRef m4aFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)m4aUrl, kAudioFileM4AType,
                                                          &m4aDescription, channelLayout.layout,
                                                          kAudioFileFlags_EraseFile, &m4aFile);
              if (status) {
                  fprintf(stderr, "error creating M4A file: %x\n", status);
                  free(audioBuffer);
                  return 1;
              }
              status = ExtAudioFileSetProperty(m4aFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                  fprintf(stderr, "error setting M4A client format: %x\n", status);
                  ExtAudioFileDispose(m4aFile);
                  free(audioBuffer);
                  return 1;
              }
              status = ExtAudioFileSetProperty(m4aFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                  fprintf(stderr, "error setting M4A channel layout: %x\n", status);
                  ExtAudioFileDispose(m4aFile);
                  free(audioBuffer);
                  return 1;
              }
              for (int i = 0; i < totalSamples; i += samplesPerBuffer) {
                  int samplesToWrite = (i + samplesPerBuffer <= totalSamples) ? samplesPerBuffer : (totalSamples - i);
                  for (int j = 0; j < samplesToWrite; j++) {
                      audioBuffer[j] = sin(2 * M_PI * 440 * (i + j) / sampleRate) * 0.5f;
                  }
                  AudioBufferList audioBufferList{
                      .mNumberBuffers = 1,
                      .mBuffers = {
                          {
                              .mNumberChannels = 1,
                              .mDataByteSize = static_cast<UInt32>(samplesToWrite * sizeof(float)),
                              .mData = audioBuffer,
                          },
                      },
                  };
                  status = ExtAudioFileWrite(m4aFile, samplesToWrite, &audioBufferList);
                  if (status) {
                      fprintf(stderr, "error writing M4A audio: %x\n", status);
                      ExtAudioFileDispose(m4aFile);
                      free(audioBuffer);
                      return 1;
                  }
              }
              free(audioBuffer);
              status = ExtAudioFileDispose(m4aFile);
              if (status) {
                  fprintf(stderr, "error closing M4A file: %x\n", status);
                  return 1;
              }
              return 0;
          }
          EOF
          echo "encodeme.mm patched at $(date)"

      # Patch fuzzer.mm
      - name: Patch fuzzer.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Patching fuzzer.mm at $(date)"
          cat > fuzzer.mm << 'EOF'
          #import <Foundation/Foundation.h>
          #import <AVFAudio/AVFAudio.h>
          #import <AudioToolbox/AudioToolbox.h>
          #import <os/log.h>
          #include <vector>
          #include <random>
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>
          #include <fcntl.h>
          #include <unistd.h>

          struct CodecConfig {
              char padding0[0x78];
              AudioChannelLayout* remappingChannelLayout;
              char padding1[0xe0 - 0x80];
              std::vector<char> mRemappingArray;

              CodecConfig() : remappingChannelLayout(nullptr) {}
              ~CodecConfig() {
                  if (remappingChannelLayout) {
                      free(remappingChannelLayout);
                  }
              }
          };

          void OverrideApac(CodecConfig* config) {
              if (config->remappingChannelLayout) {
                  config->remappingChannelLayout->mChannelLayoutTag = kAudioChannelLayoutTag_Mono;
              }
              config->mRemappingArray.resize(512, 0xff);
          }

          void handleCrash(int sig) {
              FILE* logFile = fopen("fuzzer_crash.log", "a");
              if (logFile) {
                  fprintf(logFile, "Crash detected: Signal %d at %s\n", sig, ctime(&(time_t){time(NULL)}));
                  fclose(logFile);
              }
              fprintf(stderr, "Crash detected: Signal %d\n", sig);
              exit(1);
          }

          NSString* generateFuzzedAudio(NSString* inputPath, bool isMP3) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  fprintf(logFile, "Generating fuzzed audio at %s\n", ctime(&(time_t){time(NULL)}));
              }
              std::vector<double> sampleRates = {44100};
              std::vector<AudioFormatID> formats = {kAudioFormatMPEG4AAC};
              std::random_device rd;
              std::mt19937 gen(rd());
              std::uniform_int_distribution<> formatDist(0, formats.size() - 1);
              std::uniform_int_distribution<> rateDist(0, sampleRates.size() - 1);

              double sampleRate = sampleRates[rateDist(gen)];
              AudioFormatID formatID = formats[formatDist(gen)];
              uint32_t channelNum = 1;

              if (logFile) {
                  fprintf(logFile, "Params: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                          sampleRate, formatID, channelNum, isMP3);
              }
              fprintf(stderr, "Generating fuzzed audio: sampleRate=%.0f, formatID=%u, channels=%u, isMP3=%d\n", 
                      sampleRate, formatID, channelNum, isMP3);

              AVAudioFormat* formatIn = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channelNum];
              AudioStreamBasicDescription outputDesc = {
                  .mSampleRate = sampleRate,
                  .mFormatID = formatID,
                  .mFormatFlags = 0,
                  .mBytesPerPacket = 0,
                  .mFramesPerPacket = 1024,
                  .mBytesPerFrame = 0,
                  .mChannelsPerFrame = channelNum,
                  .mBitsPerChannel = 0,
                  .mReserved = 0
              };

              AVAudioChannelLayout* channelLayout = [[AVAudioChannelLayout alloc] initWithLayoutTag:kAudioChannelLayoutTag_Mono];
              CodecConfig config;
              AudioChannelLayout* layoutCopy = (AudioChannelLayout*)malloc(sizeof(AudioChannelLayout));
              if (!layoutCopy) {
                  if (logFile) {
                      fprintf(logFile, "Memory allocation failed for rate %.0f\n", sampleRate);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Memory allocation failed for rate %.0f\n", sampleRate);
                  return nil;
              }
              memcpy(layoutCopy, channelLayout.layout, sizeof(AudioChannelLayout));
              config.remappingChannelLayout = layoutCopy;
              OverrideApac(&config);

              NSString* fileName = [NSString stringWithFormat:@"fuzzed_%.0f_%u.%@", sampleRate, formatID, isMP3 ? @"mp3" : @"m4a"];
              NSString* tempPath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];
              NSURL* outUrl = [NSURL fileURLWithPath:tempPath];

              if (logFile) {
                  fprintf(logFile, "Creating file at path: %s\n", tempPath.UTF8String);
              }
              fprintf(stderr, "Creating file at path: %s\n", tempPath.UTF8String);

              ExtAudioFileRef audioFile = nullptr;
              OSStatus status = ExtAudioFileCreateWithURL((__bridge CFURLRef)outUrl,
                                                         isMP3 ? kAudioFileMP3Type : kAudioFileM4AType,
                                                         &outputDesc, config.remappingChannelLayout,
                                                         kAudioFileFlags_EraseFile, &audioFile);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error creating file (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientDataFormat,
                                               sizeof(AudioStreamBasicDescription), formatIn.streamDescription);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting format (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              status = ExtAudioFileSetProperty(audioFile, kExtAudioFileProperty_ClientChannelLayout,
                                               sizeof(AudioChannelLayout), formatIn.channelLayout.layout);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error setting layout (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                  ExtAudioFileDispose(audioFile);
                  free(layoutCopy);
                  return nil;
              }

              float audioBuffer[1024];
              std::uniform_real_distribution<float> dis(-1.0f, 1.0f);
              for (int i = 0; i < 1024; ++i) {
                  audioBuffer[i] = dis(gen) * 0.5f;
              }
              AudioBufferList bufferList = {
                  .mNumberBuffers = 1,
                  .mBuffers = {{.mNumberChannels = channelNum, .mDataByteSize = sizeof(audioBuffer), .mData = audioBuffer}}
              };
              status = ExtAudioFileWrite(audioFile, sizeof(audioBuffer) / sizeof(audioBuffer[0]), &bufferList);
              if (status) {
                  if (logFile) {
                      fprintf(logFile, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Error writing audio (rate %.0f, format %u): %x\n", sampleRate, formatID, status);
              }

              ExtAudioFileDispose(audioFile);
              free(layoutCopy);
              if (logFile) {
                  fclose(logFile);
              }
              return tempPath;
          }

          NSMutableData* generateFuzzedBuffer(NSUInteger len) {
              NSMutableData *buffer = [NSMutableData dataWithLength:len];
              uint8_t *bytes = (uint8_t *)buffer.mutableBytes;

              for (NSUInteger i = 0; i < len; i++) {
                  bytes[i] = rand() % 256;
              }

              int mutations = rand() % 5 + 3;
              for (int i = 0; i < mutations; i++) {
                  NSUInteger offset = rand() % len;
                  bytes[offset] = (rand() % 2) ? 0x00 : 0xFF;
              }

              return buffer;
          }

          void audioQueueCallback(void *userData, AudioQueueRef queue, AudioQueueBufferRef buffer) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  fprintf(logFile, "AudioQueue callback at %s\n", ctime(&(time_t){time(NULL)}));
              }
              NSMutableData *fuzzed = generateFuzzedBuffer(buffer->mAudioDataBytesCapacity);
              buffer->mAudioDataByteSize = fuzzed.length;
              memcpy(buffer->mAudioData, fuzzed.bytes, fuzzed.length);

              AudioStreamPacketDescription *packets = NULL;
              UInt32 numPackets = rand() % 5;
              if (numPackets) {
                  packets = (AudioStreamPacketDescription*)malloc(numPackets * sizeof(AudioStreamPacketDescription));
                  for (UInt32 i = 0; i < numPackets; i++) {
                      packets[i].mStartOffset = rand() % buffer->mAudioDataByteSize;
                      packets[i].mDataByteSize = rand() % (buffer->mAudioDataByteSize - packets[i].mStartOffset + 1);
                      packets[i].mVariableFramesInPacket = rand() % 5;
                  }
              }

              OSStatus status = AudioQueueEnqueueBuffer(queue, buffer, numPackets, packets);
              if (status != noErr) {
                  if (logFile) {
                      fprintf(logFile, "Enqueue failed: %d\n", (int)status);
                      fclose(logFile);
                  }
                  fprintf(stderr, "Enqueue failed: %d\n", (int)status);
              }

              free(packets);
              if (logFile) {
                  fclose(logFile);
              }
          }

          void fuzzAudioQueue(AudioQueueRef queue) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              AudioQueueParameterID param = kAudioQueueParam_PlayRate;
              AudioQueueParameterValue rate = ((float)(rand() % 200 - 50) / 100.0f);
              if (logFile) {
                  fprintf(logFile, "Setting play rate: %f at %s\n", rate, ctime(&(time_t){time(NULL)}));
                  fclose(logFile);
              }
              AudioQueueSetParameter(queue, param, rate);
          }

          void fuzzAVAudioPlayer(AVAudioPlayer *player) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              float rate = ((float)(rand() % 200 - 50) / 100.0f);
              if (logFile) {
                  fprintf(logFile, "Fuzzed rate: %f at %s\n", rate, ctime(&(time_t){time(NULL)}));
              }
              fprintf(stderr, "-> Fuzzed rate: %f\n", rate);
              player.rate = rate;

              NSTimeInterval time = ((double)(rand() % 500) / 100.0);
              if (logFile) {
                  fprintf(logFile, "Fuzzed time: %f\n", time);
              }
              fprintf(stderr, "-> Fuzzed time: %f\n", time);
              player.currentTime = time;

              if (rand() % 2) {
                  if (logFile) {
                      fprintf(logFile, "Playing and stopping player\n");
                      fclose(logFile);
                  }
                  [player play];
                  usleep(rand() % 20000);
                  [player stop];
              } else if (logFile) {
                  fclose(logFile);
              }
          }

          void fuzzMediaToolbox(NSString *path, NSError **err) {
              FILE* logFile = fopen("fuzzer_detail.log", "a");
              if (logFile) {
                  fprintf(logFile, "MediaToolbox fuzzing requires headers at %s\n", ctime(&(time_t){time(NULL)}));
                  fclose(logFile);
              }
              fprintf(stderr, "MediaToolbox fuzzing requires headers\n");
          }

          int main(int argc, char *argv[]) {
              @autoreleasepool {
                  FILE* logFile = fopen("fuzzer_detail.log", "a");
                  if (logFile) {
                      fprintf(logFile, "Starting fuzzing at %s\n", ctime(&(time_t){time(NULL)}));
                  }
                  signal(SIGSEGV, handleCrash);
                  signal(SIGABRT, handleCrash);
                  signal(SIGILL, handleCrash);

                  NSString *inputPath = @"output.m4a";
                  if (argc > 1) {
                      inputPath = @(argv[1]);
                      if (logFile) {
                          fprintf(logFile, "Using input path: %s\n", inputPath.UTF8String);
                      }
                  }

                  int iterations = 5;
                  if (argc > 2) {
                      iterations = atoi(argv[2]);
                      if (logFile) {
                          fprintf(logFile, "Setting iterations: %d\n", iterations);
                      }
                  }

                  for (int i = 0; i < iterations; i++) {
                      if (logFile) {
                          fprintf(logFile, "Iteration %d/%d at %s\n", i + 1, iterations, ctime(&(time_t){time(NULL)}));
                      }
                      fprintf(stderr, "Iteration %d/%d\n", i + 1, iterations);

                      bool isMP3 = false;
                      NSString *tempPath = generateFuzzedAudio(inputPath, isMP3);
                      if (!tempPath) {
                          if (logFile) {
                              fprintf(logFile, "Failed to generate fuzzed audio\n");
                          }
                          fprintf(stderr, "Failed to generate fuzzed audio\n");
                          continue;
                      }

                      AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithContentsOfURL:[NSURL fileURLWithPath:tempPath] error:nil];
                      if (player) {
                          player.enableRate = YES;
                          fuzzAVAudioPlayer(player);
                          [player play];
                          usleep(rand() % 50000);
                          [player stop];
                      } else {
                          if (logFile) {
                              fprintf(logFile, "Player init failed for %s\n", tempPath.UTF8String);
                          }
                          fprintf(stderr, "Player init failed for %s\n", tempPath.UTF8String);
                      }

                      AudioStreamBasicDescription desc = {
                          .mSampleRate = 44100,
                          .mFormatID = kAudioFormatLinearPCM,
                          .mFormatFlags = kAudioFormatFlagIsSignedInteger | kAudioFormatFlagIsPacked,
                          .mBitsPerChannel = 16,
                          .mChannelsPerFrame = 1,
                          .mFramesPerPacket = 1,
                          .mBytesPerFrame = 2,
                          .mBytesPerPacket = 2
                      };
                      AudioQueueRef queue;
                      OSStatus status = AudioQueueNewOutput(&desc, audioQueueCallback, NULL, CFRunLoopGetCurrent(), kCFRunLoopCommonModes, 0, &queue);
                      if (status != noErr) {
                          if (logFile) {
                              fprintf(logFile, "Queue creation failed: %d\n", (int)status);
                          }
                          fprintf(stderr, "Queue creation failed: %d\n", (int)status);
                          continue;
                      }

                      for (int j = 0; j < 3; j++) {
                          AudioQueueBufferRef buffer;
                          UInt32 size = rand() % 100000 + 500;
                          if (AudioQueueAllocateBuffer(queue, size, &buffer) == noErr) {
                              audioQueueCallback(NULL, queue, buffer);
                          }
                      }

                      fuzzAudioQueue(queue);
                      AudioQueueStart(queue, NULL);
                      usleep(rand() % 50000);
                      AudioQueueStop(queue, true);
                      AudioQueueDispose(queue, true);

                      fuzzMediaToolbox(tempPath, nil);

                      [[NSFileManager defaultManager] removeItemAtPath:tempPath error:nil];

                      if (logFile) {
                          fprintf(logFile, "Completed iteration %d\n", i + 1);
                      }
                      fprintf(stderr, "Completed iteration %d\n", i + 1);
                  }

                  if (logFile) {
                      fprintf(logFile, "Fuzzing completed at %s\n", ctime(&(time_t){time(NULL)}));
                      fclose(logFile);
                  }
                  fprintf(stderr, "Fuzzing completed\n");
              }
              return 0;
          }
          EOF
          echo "fuzzer.mm patched at $(date)"

      # Cache FFmpeg to speed up installation
      - name: Cache FFmpeg
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/ffmpeg
          key: ffmpeg-${{ runner.os }}-2025-06
          restore-keys: ffmpeg-${{ runner.os }}-

      # Install FFmpeg if not cached
      - name: Install FFmpeg
        run: |
          echo "Installing FFmpeg at $(date)"
          if ! command -v ffmpeg &> /dev/null; then
            brew install ffmpeg
          else
            echo "FFmpeg already installed"
          fi
          echo "FFmpeg installed at $(date)"

      # Set up Xcode
      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      # Verify Xcode and clang version
      - name: Verify Xcode and clang version
        run: |
          echo "Verifying Xcode and clang versions at $(date)"
          xcodebuild -version
          clang++ --version
          xcrun --sdk macosx --show-sdk-path
          echo "Verification completed at $(date)"

      # Check system resources
      - name: Check system resources
        run: |
          echo "Checking system resources at $(date)"
          df -h
          system_profiler SPHardwareDataType
          echo "System resource check completed at $(date)"

      # Verify source files
      - name: Verify source files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Verifying files at $(date)"
          for file in encodeme.mm fuzzer.mm; do
            if [ -f "$file" ]; then
              echo "$file found"
              ls -l "$file"
            else
              echo "$file not found"
              ls -l
              exit 1
            fi
          done
          echo "File verification completed at $(date)"

      # Compile encodeme.mm for macOS
      - name: Compile encodeme.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling encodeme.mm at $(date)"
          clang++ -g -Os -std=c++2b -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot $(xcrun --sdk macosx --show-sdk-path) -framework AVFAudio -framework AudioToolbox encodeme.mm -o encodeme
          if [ $? -eq 0 ]; then
            echo "Compilation successful"
            ls -l encodeme || echo "Compiled binary 'encodeme' not found"
            BINARY_SIZE=$(stat -f %z encodeme 2>/dev/null || stat -c %s encodeme 2>/dev/null)
            echo "Binary size: $BINARY_SIZE bytes"
          else
            echo "Compilation failed"
            exit 1
          fi

      # Compile fuzzer.mm for macOS
      - name: Compile fuzzer.mm
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Compiling fuzzer.mm at $(date)"
          clang++ -g -Os -std=c++2b -fmodules -fcxx-modules -fobjc-arc -arch arm64 -isysroot $(xcrun --sdk macosx --show-sdk-path) -framework AVFAudio -framework AudioToolbox -framework Foundation fuzzer.mm -o fuzzer
          if [ $? -eq 0 ]; then
            echo "Compilation successful"
            ls -l fuzzer || echo "Compiled binary 'fuzzer' not found"
            BINARY_SIZE=$(stat -f %z fuzzer 2>/dev/null || stat -c %s fuzzer 2>/dev/null)
            echo "Binary size: $BINARY_SIZE bytes"
          else
            echo "Compilation failed"
            exit 1
          fi

      # Run encodeme to generate output.m4a
      - name: Run encodeme
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running encodeme at $(date)"
          chmod +x encodeme
          ./encodeme
          if [ $? -eq 0 ]; then
            echo "encodeme executed successfully"
          else
            echo "encodeme execution failed"
            exit 1
          fi

      # Convert M4A to MP3
      - name: Convert M4A to MP3
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Converting output.m4a to output.mp3 at $(date)"
          ffmpeg -i output.m4a -c:a mp3 -b:a 128k -ac 1 output.mp3
          if [ $? -eq 0 ]; then
            echo "Conversion successful"
          else
            echo "Conversion failed"
            exit 1
          fi

      # Run fuzzer with output.m4a as input
      - name: Run fuzzer
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Running fuzzer at $(date)"
          chmod +x fuzzer
          ./fuzzer output.m4a 5 > fuzzer.log 2>&1 || true
          if [ $? -eq 0 ]; then
            echo "fuzzer executed successfully"
          else
            echo "fuzzer execution failed"
            cat fuzzer.log
          fi
          ls -lh fuzzer.log fuzzer_detail.log fuzzer_crash.log 2>/dev/null || echo "One or more log files not found"

      # Collect system logs (fallback to fuzzer logs)
      - name: Collect system logs
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Collecting system logs at $(date)"
          if log show --predicate 'subsystem == "com.example.fuzzer"' --info --error --last 5m > system_fuzzer.log 2>&1; then
            echo "System logs collected"
            ls -lh system_fuzzer.log
          else
            echo "Failed to collect system logs, relying on fuzzer logs"
            echo "System log collection failed at $(date)" > system_fuzzer.log
          fi
          for log in fuzzer_detail.log fuzzer_crash.log; do
            if [ -f "$log" ]; then
              echo "$log found, size: $(stat -f %z "$log" 2>/dev/null || stat -c %s "$log" 2>/dev/null) bytes"
            else
              echo "$log not found"
            fi
          done

      # Collect crash reports
      - name: Collect crash reports
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Collecting crash reports at $(date)"
          mkdir -p crash_reports
          cp ~/Library/Logs/DiagnosticReports/fuzzer*.crash crash_reports/ 2>/dev/null || echo "No crash reports found"
          ls -lh crash_reports/ 2>/dev/null || echo "No crash reports copied"

      # Verify generated files
      - name: Verify generated files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Checking for generated files at $(date)"
          for file in output.m4a output.mp3; do
            if [ -f "$file" ]; then
              FILE_SIZE=$(stat -f %z "$file" 2>/dev/null || stat -c %s "$file" 2>/dev/null)
              echo "$file size: $FILE_SIZE bytes"
              if [ "$FILE_SIZE" -eq 0 ]; then
                echo "Error: $file is 0 bytes"
                exit 1
              fi
              ffprobe -i "$file" -show_format -show_streams -print_format json 2>/dev/null || echo "ffprobe failed for $file"
            else
              echo "$file not found"
              exit 1
            fi
          done
          echo "Checking for fuzzed files at $(date)"
          ls -lh /tmp/fuzzed_* 2>/dev/null || echo "No fuzzed files found"

      # Upload artifacts
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: audio-and-log-files
          path: |
            AppleTest/apple-positional-audio-codec-invalid-header-main/output.m4a
            AppleTest/apple-positional-audio-codec-invalid-header-main/output.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer_detail.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/fuzzer_crash.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/system_fuzzer.log
            AppleTest/apple-positional-audio-codec-invalid-header-main/crash_reports/*.crash
            /tmp/fuzzed_*.m4a
          retention-days: 7
          if-no-files-found: warn
